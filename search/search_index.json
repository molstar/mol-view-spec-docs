{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MolViewSpec MolViewSpec (MVS) is a toolkit for standardized description of reproducible molecular visualizations shareable across software applications. MolViewSpec describes a 3D molecular scene by a MolViewSpec State, a viewer-independent representation that contains all information necessary to reproduce the scene. Thanks to its nested tree-based format, complex scenes can be composed from simple building blocks. The MolViewSpec toolkit includes: Specification of the MolViewSpec format defines the structure of the MolViewSpec States and the properties of individual nodes of the tree data structure. The specification is provided by this documentation and formalized by the OpenAPI JSON Schema . MolViewSpec builder API provides a mechanism for building and validating MolViewSpec States. The API is available in multiple programming languages: in Python via MolViewSpec Python package in JavaScript/TypeScript via MolViewSpec extension in Mol* MolViewSpec viewer extensions provide ability to interpret and render MolViewSpec States in individual molecular viewers. Currently, there is only one viewer extension: MolViewSpec extension in Mol* . This extension also serves as the reference implementation for MolViewSpec viewer extensions. Additional sources MolViewSpec home page with plenty of examples Interactive Google Colab example showing the MolViewSpec Python package in action MolViewSpec functionality overview MolViewSpec uses a tree-based approach to compose complex scenes from simple building blocks. The following list is a high-level overview of these blocks: Download - define source of structural data Parse - parse structural data in various formats Structure - create structure (supports assemblies, crystal symmetry, multi-model structures) Transform - apply rotation and translation to a structure Component - select substructures (components) of a structure, e.g. by chain identifier or sequence position Representation - define structure representation modes (cartoon, ball-and-stick, ...), including support for coarse-grained IHM data Color - define custom colors (including opacity) for selections Label - define labels (textual representation in the 3D scene) Tooltip - define tooltips (text shown when interacting with a component) Camera - set camera position and orientation explicitly Focus - set camera position and orientation automatically to focus a given component (optionally: render non-covalent interactions) Volumetric Data - render electron density data Canvas - set background color Annotations - create data-driven components, colorings, labels, or tooltips; based on MolViewSpec annotations (additional data stored either in the source structure file (mmcif, bcif) or in an external annotation file referenced by URI) Primitives - draw custom ellipses, boxes, arrows, or meshes Multiple States & Animations - tell molecular stories by chaining individual scenes and views MolViewSpec data structure MVS is based on a tree format, i.e. a molecular view is described as a nested tree where individual nodes represent data operations needed to create the view. Each node is defined by its kind (specifies the type of operation, e.g. download , parse , color ) and parameters (provide additional details for the operation, e.g. url , format , selector ). A simple example of a MVS tree showing PDB structure 1cbs: \u2500root {} \u251c\u2500\u2500download {url: \"https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif\"} \u2502 \u2514\u2500\u2500parse {format: \"bcif\"} \u2502 \u2514\u2500\u2500structure {type: \"model\"} \u2502 \u251c\u2500\u2500component {selector: \"polymer\"} \u2502 \u2502 \u251c\u2500\u2500representation {type: \"cartoon\"} \u2502 \u2502 \u2502 \u251c\u2500\u2500color {color: \"green\"} \u2502 \u2502 \u2502 \u2514\u2500\u2500color {selector: {label_asym_id: \"A\", beg_label_seq_id: 1, end_label_seq_id: 50}, color: \"#6688ff\"} \u2502 \u2502 \u2514\u2500\u2500label {text: \"Protein\"} \u2502 \u2514\u2500\u2500component {selector: \"ligand\"} \u2502 \u251c\u2500\u2500representation {type: \"ball_and_stick\"} \u2502 \u2502 \u2514\u2500\u2500color {color: \"#cc3399\"} \u2502 \u2514\u2500\u2500label {text: \"Retinoic Acid\"} \u251c\u2500\u2500canvas {background_color: \"#ffffee\"} \u2514\u2500\u2500camera {target: [17,21,27], position: [41,34,69], up: [-0.129,0.966,-0.224]} This is a schematic representation of the tree, not the actual data format! Each line represents a node defined by its kind (root, download, parse...) and parameters (everything within {braces}). Resulting view (created by MolViewSpec extension in Mol*): This example downloads a structure file from \"https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif\" and creates a structure from it. It defines two components of the structure (polymer and ligand) and applies different 3D representation and color to them (polymer: cartoon representation in green, with residue range 1\u201350 in chain A selective colored to light blue; ligand: ball-and-stick in magenta). It also adds a label for each component, and sets the camera orientation and background color. A complete list of supported node kinds and their parameters is described by the MVS tree schema . An OpenAPI JSON schema is avalaible in molviewspec-v1-openapi-schema.json . Encoding MVSJ A MolViewSpec tree can be encoded and stored in .mvsj format (MolViewSpec JSON), which is basically a JSON representation of the tree with additional metadata. The example above would be encoded as: { \"metadata\" : { \"title\" : \"Example MolViewSpec - 1cbs with labelled protein and ligand\" , \"version\" : \"1\" , \"timestamp\" : \"2023-11-24T10:38:17.483Z\" }, \"root\" : { \"kind\" : \"root\" , \"children\" : [ { \"kind\" : \"download\" , \"params\" : { \"url\" : \"https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif\" }, \"children\" : [ { \"kind\" : \"parse\" , \"params\" : { \"format\" : \"bcif\" }, \"children\" : [ ... Complete file: 1cbs.mvsj MVSX The MolViewSpec tree can also be stored in a .mvsx format. This is simply a ZIP archive containing: main file index.mvsj (contains the MolViewSpec tree encoded as MVSJ), any number of other files, such as MVS annotations or structure files. The advantage of this format is that the main file can reference other files in the archive using relative URIs. Thus the view description along with all necessary data can be stored as a single MVSX file. It is important that the index.mvsj be at the top level of the archive, not in a subdirectory. When creating the archive from command line: $ ls example/ annotations-1h9t.cif index.mvsj $ zip -r example.mvsx example/ # Wrong, won't create a valid MVSX file $ cd example/; zip -r ../example.mvsx * # Correct Example: 1ht9.mvsx Topics MVS tree schema Selectors Annotations Camera settings Primitives Volumetric Data Animations MolViewSpec extension in Mol* MolViewSpec extension in Mol* - Integration in web pages Demos: Molecular story telling & I/HM restraints","title":"Introduction"},{"location":"#molviewspec","text":"MolViewSpec (MVS) is a toolkit for standardized description of reproducible molecular visualizations shareable across software applications. MolViewSpec describes a 3D molecular scene by a MolViewSpec State, a viewer-independent representation that contains all information necessary to reproduce the scene. Thanks to its nested tree-based format, complex scenes can be composed from simple building blocks. The MolViewSpec toolkit includes: Specification of the MolViewSpec format defines the structure of the MolViewSpec States and the properties of individual nodes of the tree data structure. The specification is provided by this documentation and formalized by the OpenAPI JSON Schema . MolViewSpec builder API provides a mechanism for building and validating MolViewSpec States. The API is available in multiple programming languages: in Python via MolViewSpec Python package in JavaScript/TypeScript via MolViewSpec extension in Mol* MolViewSpec viewer extensions provide ability to interpret and render MolViewSpec States in individual molecular viewers. Currently, there is only one viewer extension: MolViewSpec extension in Mol* . This extension also serves as the reference implementation for MolViewSpec viewer extensions.","title":"MolViewSpec"},{"location":"#additional-sources","text":"MolViewSpec home page with plenty of examples Interactive Google Colab example showing the MolViewSpec Python package in action","title":"Additional sources"},{"location":"#molviewspec-functionality-overview","text":"MolViewSpec uses a tree-based approach to compose complex scenes from simple building blocks. The following list is a high-level overview of these blocks: Download - define source of structural data Parse - parse structural data in various formats Structure - create structure (supports assemblies, crystal symmetry, multi-model structures) Transform - apply rotation and translation to a structure Component - select substructures (components) of a structure, e.g. by chain identifier or sequence position Representation - define structure representation modes (cartoon, ball-and-stick, ...), including support for coarse-grained IHM data Color - define custom colors (including opacity) for selections Label - define labels (textual representation in the 3D scene) Tooltip - define tooltips (text shown when interacting with a component) Camera - set camera position and orientation explicitly Focus - set camera position and orientation automatically to focus a given component (optionally: render non-covalent interactions) Volumetric Data - render electron density data Canvas - set background color Annotations - create data-driven components, colorings, labels, or tooltips; based on MolViewSpec annotations (additional data stored either in the source structure file (mmcif, bcif) or in an external annotation file referenced by URI) Primitives - draw custom ellipses, boxes, arrows, or meshes Multiple States & Animations - tell molecular stories by chaining individual scenes and views","title":"MolViewSpec functionality overview"},{"location":"#molviewspec-data-structure","text":"MVS is based on a tree format, i.e. a molecular view is described as a nested tree where individual nodes represent data operations needed to create the view. Each node is defined by its kind (specifies the type of operation, e.g. download , parse , color ) and parameters (provide additional details for the operation, e.g. url , format , selector ). A simple example of a MVS tree showing PDB structure 1cbs: \u2500root {} \u251c\u2500\u2500download {url: \"https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif\"} \u2502 \u2514\u2500\u2500parse {format: \"bcif\"} \u2502 \u2514\u2500\u2500structure {type: \"model\"} \u2502 \u251c\u2500\u2500component {selector: \"polymer\"} \u2502 \u2502 \u251c\u2500\u2500representation {type: \"cartoon\"} \u2502 \u2502 \u2502 \u251c\u2500\u2500color {color: \"green\"} \u2502 \u2502 \u2502 \u2514\u2500\u2500color {selector: {label_asym_id: \"A\", beg_label_seq_id: 1, end_label_seq_id: 50}, color: \"#6688ff\"} \u2502 \u2502 \u2514\u2500\u2500label {text: \"Protein\"} \u2502 \u2514\u2500\u2500component {selector: \"ligand\"} \u2502 \u251c\u2500\u2500representation {type: \"ball_and_stick\"} \u2502 \u2502 \u2514\u2500\u2500color {color: \"#cc3399\"} \u2502 \u2514\u2500\u2500label {text: \"Retinoic Acid\"} \u251c\u2500\u2500canvas {background_color: \"#ffffee\"} \u2514\u2500\u2500camera {target: [17,21,27], position: [41,34,69], up: [-0.129,0.966,-0.224]} This is a schematic representation of the tree, not the actual data format! Each line represents a node defined by its kind (root, download, parse...) and parameters (everything within {braces}). Resulting view (created by MolViewSpec extension in Mol*): This example downloads a structure file from \"https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif\" and creates a structure from it. It defines two components of the structure (polymer and ligand) and applies different 3D representation and color to them (polymer: cartoon representation in green, with residue range 1\u201350 in chain A selective colored to light blue; ligand: ball-and-stick in magenta). It also adds a label for each component, and sets the camera orientation and background color. A complete list of supported node kinds and their parameters is described by the MVS tree schema . An OpenAPI JSON schema is avalaible in molviewspec-v1-openapi-schema.json .","title":"MolViewSpec data structure"},{"location":"#encoding","text":"","title":"Encoding"},{"location":"#mvsj","text":"A MolViewSpec tree can be encoded and stored in .mvsj format (MolViewSpec JSON), which is basically a JSON representation of the tree with additional metadata. The example above would be encoded as: { \"metadata\" : { \"title\" : \"Example MolViewSpec - 1cbs with labelled protein and ligand\" , \"version\" : \"1\" , \"timestamp\" : \"2023-11-24T10:38:17.483Z\" }, \"root\" : { \"kind\" : \"root\" , \"children\" : [ { \"kind\" : \"download\" , \"params\" : { \"url\" : \"https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif\" }, \"children\" : [ { \"kind\" : \"parse\" , \"params\" : { \"format\" : \"bcif\" }, \"children\" : [ ... Complete file: 1cbs.mvsj","title":"MVSJ"},{"location":"#mvsx","text":"The MolViewSpec tree can also be stored in a .mvsx format. This is simply a ZIP archive containing: main file index.mvsj (contains the MolViewSpec tree encoded as MVSJ), any number of other files, such as MVS annotations or structure files. The advantage of this format is that the main file can reference other files in the archive using relative URIs. Thus the view description along with all necessary data can be stored as a single MVSX file. It is important that the index.mvsj be at the top level of the archive, not in a subdirectory. When creating the archive from command line: $ ls example/ annotations-1h9t.cif index.mvsj $ zip -r example.mvsx example/ # Wrong, won't create a valid MVSX file $ cd example/; zip -r ../example.mvsx * # Correct Example: 1ht9.mvsx","title":"MVSX"},{"location":"#topics","text":"MVS tree schema Selectors Annotations Camera settings Primitives Volumetric Data Animations MolViewSpec extension in Mol* MolViewSpec extension in Mol* - Integration in web pages Demos: Molecular story telling & I/HM restraints","title":"Topics"},{"location":"animations/","text":"MolViewSpec animations Animations are sequential collections of individual MolViewSpec scenes. You can combine them freely into complex stories that render scenes one-by-one. The Mol* viewer can interpolate between these states, providing you with a powerful story telling tool tailored to structural biology. Creating snapshots Use the builder as normal and define the desired scene. Invoke get_snapshot() to obtain a snapshot instance (in contrast to the default way of emitting the generated state description using get_state() ). snapshot1 = builder . get_snapshot ( title = \"1tqn\" , description = \"\"\" ### 1tqn with ligand and electron density map - 2FO-FC at 1.5\u03c3, blue - FO-FC (positive) at 3\u03c3, green - FO-FC (negative) at -3\u03c3, red \"\"\" , ) A snapshot can hold additional metadata such as a custom title and description. Markup is supported. Combining snapshots Individual snapshots can then be combined into an animation by providing them in the desired order using the snapshots parameter. Additionally, global metadata can be added that describes shared properties of all snapshots. states = States ( snapshots = [ snapshot1 , snapshot2 ], metadata = GlobalMetadata ( description = \"1tqn + Volume Server\" )) . json ( exclude_none = True , indent = 2 ) The output is valid MolViewSpec JSON that can be opened in Mol . Mol will interpolate between individual substates and add smooth transitions by default. You can further customize this behavior using the transition_duration_ms and linger_duration_ms properties.","title":"Animations"},{"location":"animations/#molviewspec-animations","text":"Animations are sequential collections of individual MolViewSpec scenes. You can combine them freely into complex stories that render scenes one-by-one. The Mol* viewer can interpolate between these states, providing you with a powerful story telling tool tailored to structural biology.","title":"MolViewSpec animations"},{"location":"animations/#creating-snapshots","text":"Use the builder as normal and define the desired scene. Invoke get_snapshot() to obtain a snapshot instance (in contrast to the default way of emitting the generated state description using get_state() ). snapshot1 = builder . get_snapshot ( title = \"1tqn\" , description = \"\"\" ### 1tqn with ligand and electron density map - 2FO-FC at 1.5\u03c3, blue - FO-FC (positive) at 3\u03c3, green - FO-FC (negative) at -3\u03c3, red \"\"\" , ) A snapshot can hold additional metadata such as a custom title and description. Markup is supported.","title":"Creating snapshots"},{"location":"animations/#combining-snapshots","text":"Individual snapshots can then be combined into an animation by providing them in the desired order using the snapshots parameter. Additionally, global metadata can be added that describes shared properties of all snapshots. states = States ( snapshots = [ snapshot1 , snapshot2 ], metadata = GlobalMetadata ( description = \"1tqn + Volume Server\" )) . json ( exclude_none = True , indent = 2 ) The output is valid MolViewSpec JSON that can be opened in Mol . Mol will interpolate between individual substates and add smooth transitions by default. You can further customize this behavior using the transition_duration_ms and linger_duration_ms properties.","title":"Combining snapshots"},{"location":"annotations/","text":"MolViewSpec annotations Annotations are used to define substructures (components) and apply colors, labels, or tooltips to them. In contrast to selectors , annotations are defined in a separate file, which can then be referenced in the main MVS file. MVS annotation files MVS annotations can be encoded in multiple different formats, but their logic is always the same and in fact very similar to that of selectors. JSON format The simplest example of an annotation in JSON format is just a JSON-encoded union component expression selector. Here is a simple annotation containing 4 annotation rows : [ { \"label_asym_id\" : \"A\" }, { \"label_asym_id\" : \"B\" }, { \"label_asym_id\" : \"B\" , \"beg_label_seq_id\" : 100 , \"end_label_seq_id\" : 200 }, { \"label_asym_id\" : \"B\" , \"beg_label_seq_id\" : 150 , \"end_label_seq_id\" : 160 } ] However, in a typical annotation, there is at least one extra field that provides the value of the dependent variable (such as color or label) mapped to each annotation row: [ { \"label_asym_id\" : \"A\" , \"color\" : \"#00ff00\" }, { \"label_asym_id\" : \"B\" , \"color\" : \"blue\" }, { \"label_asym_id\" : \"B\" , \"beg_label_seq_id\" : 100 , \"end_label_seq_id\" : 200 , \"color\" : \"skyblue\" } { \"label_asym_id\" : \"B\" , \"beg_label_seq_id\" : 150 , \"end_label_seq_id\" : 160 , \"color\" : \"lightblue\" } ] This particular annotation (when applied via color_from_uri node) will apply green color (#00ff00) to the whole chain A and three shades of blue to the chain B. Later annotation rows override earlier rows, therefore residues 1\u201399 will be blue, 100\u2013149 skyblue, 150\u2013160 lightblue, 161\u2013200 skyblue, and 201\u2013end blue. (Tip: to color all the rest of the structure in one color, add an annotation row with no selector fields (e.g. { \"color\": \"yellow\" } ) to the beginning of the annotation.) Real-life annotation files can include huge numbers of annotation rows. To avoid repeating the same field keys in every row, we can convert the array-of-objects into object-of-arrays. This will result in an equivalent annotation but smaller file size: { \"label_asym_id\" : [ \"A\" , \"B\" , \"B\" , \"B\" ], \"beg_label_seq_id\" : [ null , null , 100 , 150 ], \"end_label_seq_id\" : [ null , null , 200 , 160 ], \"color\" : [ \"#00ff00\" , \"blue\" , \"skyblue\" , \"lightblue\" ] } A more complex example of JSON annotation is provided in 1h9t_domains.json . CIF format Annotations can also be encoded using CIF format, a table-based format which is commonly used in structure biology to store structures or any kind of tabular data. The example from above, encoded as CIF, would look like this: data_annotation loop_ _coloring.label_asym_id _coloring.beg_label_seq_id _coloring.end_label_seq_id _coloring.color A . . '#00ff00' B . . 'blue' B 100 200 'skyblue' B 150 160 'lightblue' An advantage of the CIF format is that it can include multiple annotation tables in the same file, organized into blocks and categories. Then the MVS file can reference individual tables using block_header (or block_index ) and category_name parameters. The column containing the dependent variable can be specified using field_name parameter. In this case, we could use \"block_header\": \"annotation\", \"category_name\": \"coloring\", \"field_name\": \"color\" . BCIF format This has exactly the same structure as the CIF format, but encoded using BinaryCIF . Referencing MVS annotations in MVS tree From URI MVS annotations can be referenced in color_from_uri , label_from_uri , tooltip_from_uri , and component_from_uri nodes in MVS tree. For example this part of a MVS tree: - representation {type: \"cartoon\"} - color {selector: {label_asym_id: \"A\"}, color: \"#00ff00\"} - color {selector: {label_asym_id: \"B\"}, color: \"blue\"} - color {selector: {label_asym_id: \"B\", beg_label_seq_id: 100, end_label_seq_id: 200}, color: \"skyblue\"} - color {selector: {label_asym_id: \"B\", beg_label_seq_id: 150, end_label_seq_id: 160}, color: \"lightblue\"} can be replaced by: - representation {type: \"cartoon\"} - color_from_uri {uri: \"https://example.org/annotations.json\", format: \"json\", schema: \"residue_range\"} assuming that the JSON annotation file shown in the previous section is available at https://example.org/annotations.json . Relative URIs The uri parameter can also hold a URI reference (relative URI). In such cases, this URI reference is relative to the URI of the MVS file itself (e.g. if the MVS file is available from https://example.org/spanish/inquisition/expectations.mvsj , then the relative URI ./annotations.json is equivalent to https://example.org/spanish/inquisition/annotations.json ). This is however not applicable in all cases (e.g. the MVS tree can be constructed ad-hoc within a web application, therefore it has no URI; or the MVS file is loaded from a local disk using drag&drop, therefore the relative location is not accessible by the browser). A special case is when the MVS tree is saved in MVSX format. An MVSX file is a ZIP archive containing the MVS tree in index.mvsj and possibly other files. In this case, the relative URIs will resolve to the files within the archive (e.g. ./annotations.json points to the file annotations.json stored in the MSVX archive). From source The MVS annotations can in fact be stored within the same mmCIF file from which the structure coordinates are loaded. To reference these annotations, we can use color_from_source , label_from_source , tooltip_from_source , and component_from_source nodes. Example: - representation {type: \"cartoon\"} - color_from_source {schema: \"residue_range\", block_header: \"annotation\", category_name: \"coloring\"} Annotation schemas The schema parameter of all *_from_uri and *_from_source nodes specifies the MVS annotation schema, i.e. a set of fields used to select a substructure. In the example above we are using residue_range schema, which uses columns label_entity_id , label_asym_id , beg_label_seq_id , and end_label_seq_id . (We didn't provide values for label_entity_id , so it is not taken into account even though the schema supports it). Table of selector field names supported by individual MVS annotation schemas: Field \\ Schema whole_structure entity chain residue residue_range atom auth_chain auth_residue auth_residue_range auth_atom all_atomic label_entity_id X X X X X X label_asym_id X X X X X label_seq_id X X X beg_label_seq_id X X end_label_seq_id X X label_atom_id X X auth_asym_id X X X X X auth_seq_id X X X pdbx_PDB_ins_code X X X beg_auth_seq_id X X end_auth_seq_id X X auth_atom_id X X type_symbol X X X atom_id X X X atom_index X X X To include all selector field names that are present in the annotation, one can use \"schema\": \"all_atomic\" (we could use it in the example above and the result would be the same). In future versions of MVS, non-atomic schemas might be added, to select parts of structures that are not composed of atoms, e.g. coarse models or geometric primitives. group_id field The group_id field is a special field supported by all MVS annotation schemas. It does not change the sets of atoms selected by individual rows but instead groups annotation rows together to create more complex selections. This is useful when adding labels to our visualization. The following example (when applied via label_from_uri node) will create 7 separate labels, each bound to a single residue: data_annotation loop_ _labels.label_asym_id _labels.label_seq_id _labels.color _labels.label A 100 pink 'Substrate binding site' A 150 pink 'Substrate binding site' A 170 pink 'Substrate binding site' A 200 blue 'Inhibitor binding site' A 220 blue 'Inhibitor binding site' A 300 lime 'Glycosylation site' A 330 lime 'Glycosylation site' On the other hand, the next example will only create 4 labels (\"Substrate binding site\" label bound to residues 100, 150, and 170; \"Inhibitor binding site\" label bound to residues 200 and 220; \"Glycosylation site\" label bound to residue 300; and \"Glycosylation site\" label bound to residue 330): data_annotation loop_ _labels.group_id _labels.label_asym_id _labels.label_seq_id _labels.color _labels.label 1 A 100 pink 'Substrate binding site' 1 A 150 pink 'Substrate binding site' 1 A 170 pink 'Substrate binding site' 2 A 200 blue 'Inhibitor binding site' 2 A 220 blue 'Inhibitor binding site' . A 300 lime 'Glycosylation site' . A 330 lime 'Glycosylation site' Note: Annotation rows with empty group_id field ( . in CIF, ommitted field or null in JSON) are always treated as separate groups. Note 2: group_id field has no effect on colors, tooltips, components. It only makes any difference for labels.","title":"Annotations"},{"location":"annotations/#molviewspec-annotations","text":"Annotations are used to define substructures (components) and apply colors, labels, or tooltips to them. In contrast to selectors , annotations are defined in a separate file, which can then be referenced in the main MVS file.","title":"MolViewSpec annotations"},{"location":"annotations/#mvs-annotation-files","text":"MVS annotations can be encoded in multiple different formats, but their logic is always the same and in fact very similar to that of selectors.","title":"MVS annotation files"},{"location":"annotations/#json-format","text":"The simplest example of an annotation in JSON format is just a JSON-encoded union component expression selector. Here is a simple annotation containing 4 annotation rows : [ { \"label_asym_id\" : \"A\" }, { \"label_asym_id\" : \"B\" }, { \"label_asym_id\" : \"B\" , \"beg_label_seq_id\" : 100 , \"end_label_seq_id\" : 200 }, { \"label_asym_id\" : \"B\" , \"beg_label_seq_id\" : 150 , \"end_label_seq_id\" : 160 } ] However, in a typical annotation, there is at least one extra field that provides the value of the dependent variable (such as color or label) mapped to each annotation row: [ { \"label_asym_id\" : \"A\" , \"color\" : \"#00ff00\" }, { \"label_asym_id\" : \"B\" , \"color\" : \"blue\" }, { \"label_asym_id\" : \"B\" , \"beg_label_seq_id\" : 100 , \"end_label_seq_id\" : 200 , \"color\" : \"skyblue\" } { \"label_asym_id\" : \"B\" , \"beg_label_seq_id\" : 150 , \"end_label_seq_id\" : 160 , \"color\" : \"lightblue\" } ] This particular annotation (when applied via color_from_uri node) will apply green color (#00ff00) to the whole chain A and three shades of blue to the chain B. Later annotation rows override earlier rows, therefore residues 1\u201399 will be blue, 100\u2013149 skyblue, 150\u2013160 lightblue, 161\u2013200 skyblue, and 201\u2013end blue. (Tip: to color all the rest of the structure in one color, add an annotation row with no selector fields (e.g. { \"color\": \"yellow\" } ) to the beginning of the annotation.) Real-life annotation files can include huge numbers of annotation rows. To avoid repeating the same field keys in every row, we can convert the array-of-objects into object-of-arrays. This will result in an equivalent annotation but smaller file size: { \"label_asym_id\" : [ \"A\" , \"B\" , \"B\" , \"B\" ], \"beg_label_seq_id\" : [ null , null , 100 , 150 ], \"end_label_seq_id\" : [ null , null , 200 , 160 ], \"color\" : [ \"#00ff00\" , \"blue\" , \"skyblue\" , \"lightblue\" ] } A more complex example of JSON annotation is provided in 1h9t_domains.json .","title":"JSON format"},{"location":"annotations/#cif-format","text":"Annotations can also be encoded using CIF format, a table-based format which is commonly used in structure biology to store structures or any kind of tabular data. The example from above, encoded as CIF, would look like this: data_annotation loop_ _coloring.label_asym_id _coloring.beg_label_seq_id _coloring.end_label_seq_id _coloring.color A . . '#00ff00' B . . 'blue' B 100 200 'skyblue' B 150 160 'lightblue' An advantage of the CIF format is that it can include multiple annotation tables in the same file, organized into blocks and categories. Then the MVS file can reference individual tables using block_header (or block_index ) and category_name parameters. The column containing the dependent variable can be specified using field_name parameter. In this case, we could use \"block_header\": \"annotation\", \"category_name\": \"coloring\", \"field_name\": \"color\" .","title":"CIF format"},{"location":"annotations/#bcif-format","text":"This has exactly the same structure as the CIF format, but encoded using BinaryCIF .","title":"BCIF format"},{"location":"annotations/#referencing-mvs-annotations-in-mvs-tree","text":"","title":"Referencing MVS annotations in MVS tree"},{"location":"annotations/#from-uri","text":"MVS annotations can be referenced in color_from_uri , label_from_uri , tooltip_from_uri , and component_from_uri nodes in MVS tree. For example this part of a MVS tree: - representation {type: \"cartoon\"} - color {selector: {label_asym_id: \"A\"}, color: \"#00ff00\"} - color {selector: {label_asym_id: \"B\"}, color: \"blue\"} - color {selector: {label_asym_id: \"B\", beg_label_seq_id: 100, end_label_seq_id: 200}, color: \"skyblue\"} - color {selector: {label_asym_id: \"B\", beg_label_seq_id: 150, end_label_seq_id: 160}, color: \"lightblue\"} can be replaced by: - representation {type: \"cartoon\"} - color_from_uri {uri: \"https://example.org/annotations.json\", format: \"json\", schema: \"residue_range\"} assuming that the JSON annotation file shown in the previous section is available at https://example.org/annotations.json .","title":"From URI"},{"location":"annotations/#relative-uris","text":"The uri parameter can also hold a URI reference (relative URI). In such cases, this URI reference is relative to the URI of the MVS file itself (e.g. if the MVS file is available from https://example.org/spanish/inquisition/expectations.mvsj , then the relative URI ./annotations.json is equivalent to https://example.org/spanish/inquisition/annotations.json ). This is however not applicable in all cases (e.g. the MVS tree can be constructed ad-hoc within a web application, therefore it has no URI; or the MVS file is loaded from a local disk using drag&drop, therefore the relative location is not accessible by the browser). A special case is when the MVS tree is saved in MVSX format. An MVSX file is a ZIP archive containing the MVS tree in index.mvsj and possibly other files. In this case, the relative URIs will resolve to the files within the archive (e.g. ./annotations.json points to the file annotations.json stored in the MSVX archive).","title":"Relative URIs"},{"location":"annotations/#from-source","text":"The MVS annotations can in fact be stored within the same mmCIF file from which the structure coordinates are loaded. To reference these annotations, we can use color_from_source , label_from_source , tooltip_from_source , and component_from_source nodes. Example: - representation {type: \"cartoon\"} - color_from_source {schema: \"residue_range\", block_header: \"annotation\", category_name: \"coloring\"}","title":"From source"},{"location":"annotations/#annotation-schemas","text":"The schema parameter of all *_from_uri and *_from_source nodes specifies the MVS annotation schema, i.e. a set of fields used to select a substructure. In the example above we are using residue_range schema, which uses columns label_entity_id , label_asym_id , beg_label_seq_id , and end_label_seq_id . (We didn't provide values for label_entity_id , so it is not taken into account even though the schema supports it). Table of selector field names supported by individual MVS annotation schemas: Field \\ Schema whole_structure entity chain residue residue_range atom auth_chain auth_residue auth_residue_range auth_atom all_atomic label_entity_id X X X X X X label_asym_id X X X X X label_seq_id X X X beg_label_seq_id X X end_label_seq_id X X label_atom_id X X auth_asym_id X X X X X auth_seq_id X X X pdbx_PDB_ins_code X X X beg_auth_seq_id X X end_auth_seq_id X X auth_atom_id X X type_symbol X X X atom_id X X X atom_index X X X To include all selector field names that are present in the annotation, one can use \"schema\": \"all_atomic\" (we could use it in the example above and the result would be the same). In future versions of MVS, non-atomic schemas might be added, to select parts of structures that are not composed of atoms, e.g. coarse models or geometric primitives.","title":"Annotation schemas"},{"location":"annotations/#group_id-field","text":"The group_id field is a special field supported by all MVS annotation schemas. It does not change the sets of atoms selected by individual rows but instead groups annotation rows together to create more complex selections. This is useful when adding labels to our visualization. The following example (when applied via label_from_uri node) will create 7 separate labels, each bound to a single residue: data_annotation loop_ _labels.label_asym_id _labels.label_seq_id _labels.color _labels.label A 100 pink 'Substrate binding site' A 150 pink 'Substrate binding site' A 170 pink 'Substrate binding site' A 200 blue 'Inhibitor binding site' A 220 blue 'Inhibitor binding site' A 300 lime 'Glycosylation site' A 330 lime 'Glycosylation site' On the other hand, the next example will only create 4 labels (\"Substrate binding site\" label bound to residues 100, 150, and 170; \"Inhibitor binding site\" label bound to residues 200 and 220; \"Glycosylation site\" label bound to residue 300; and \"Glycosylation site\" label bound to residue 330): data_annotation loop_ _labels.group_id _labels.label_asym_id _labels.label_seq_id _labels.color _labels.label 1 A 100 pink 'Substrate binding site' 1 A 150 pink 'Substrate binding site' 1 A 170 pink 'Substrate binding site' 2 A 200 blue 'Inhibitor binding site' 2 A 220 blue 'Inhibitor binding site' . A 300 lime 'Glycosylation site' . A 330 lime 'Glycosylation site' Note: Annotation rows with empty group_id field ( . in CIF, ommitted field or null in JSON) are always treated as separate groups. Note 2: group_id field has no effect on colors, tooltips, components. It only makes any difference for labels.","title":"group_id field"},{"location":"camera-settings/","text":"MVS camera settings Camera position and orientation in MVS views can be adjusted in two ways: using a camera node or a focus node. Global attributes of the MVS view unrelated to camera positioning can be adjusted via a canvas node. camera node This node instructs to directly set the camera position and orientation. This is done by passing target , position , and optional up vector. The camera node is placed as a child of the root node (see MVS tree schema ). However, if the target and position vectors were interpreted directly, the resulting view would wildly depend on the camera field of view (FOV). For example, assume we have a sphere with center in the point [0,0,0] and radius 10 Angstroms, and we set target=[0,0,0] and position=[0,0,20] . With a camera with vertical FOV=90\u00b0, the sphere will fit into the camera's view nicely, with some margin above and under the sphere. But with a camera with vertical FOV=30\u00b0, the top and bottom of sphere will be cropped. To avoid these differences, MVS always uses position of a \"reference camera\" instead of the real camera position. We define the \"reference camera\" as a camera with such FOV that a sphere with radius R viewed from distance 2 R (from the center of the sphere) will just fit into view (i.e. there will be no margin but the sphere will not be cropped). This happens to be FOV = 2 arcsin(1/2) = 60\u00b0 for perspective projection, and FOV = 2 arctan(1/2) \u2248 53\u00b0 for orthographic projection. When using perspective projection, the real camera distance from target and the real camera position can be calculated using these formulas: \\(d _\\mathrm{adj} = d _\\mathrm{ref} \\cdot \\frac{1}{2 \\sin(\\alpha/2)}\\) \\(\\mathbf{p} _\\mathrm{adj} = \\mathbf{t} + (\\mathbf{p} _\\mathrm{ref} - \\mathbf{t}) \\cdot \\frac{1}{2 \\sin(\\alpha/2)}\\) Where \\(\\alpha\\) is the vertical FOV of the real camera, \\(d _\\mathrm{ref}\\) is the reference camera distance from target, \\(d _\\mathrm{adj}\\) is the real (adjusted) camera distance from target, \\(\\mathbf{t}\\) is the target position, \\(\\mathbf{p} _\\mathrm{ref}\\) is the reference camera position (the value in the MVS file), and \\(\\mathbf{p} _\\mathrm{adj}\\) is the real (adjusted) camera position. When using orthographic projection, the formulas are slightly different: \\(d _\\mathrm{adj} = d _\\mathrm{ref} \\cdot \\frac{1}{2 \\tan(\\alpha/2)}\\) \\(\\mathbf{p} _\\mathrm{adj} = \\mathbf{t} + (\\mathbf{p} _\\mathrm{ref} - \\mathbf{t}) \\cdot \\frac{1}{2 \\tan(\\alpha/2)}\\) The following image illustrates the camera position adjustment (left: reference camera with FOV=60\u00b0, right: real camera with FOV=30\u00b0 must be positioned further from the target to obtain a similar view): Using the example above ( target=[0,0,0] and position=[0,0,20] ), we can calculate that the real camera position will have to be set to: [0, 0, 14.14] for FOV=90\u00b0 (perspective projection) [0, 0, 20] for FOV=60\u00b0 (perspective projection) [0, 0, 38.68] for FOV=30\u00b0 (perspective projection) Note that for orthographic projection this adjustment achieves that the resulting view does not depend on the FOV value. For perspective projection, this is not possible and there will always be some \"fisheye effect\", but still it greatly reduces the dependence on FOV and avoids the too-much-zoomed-in and too-much-zoomed-out views when FOV changes. The up vector describes how the camera should be rotated around the position-target axis, i.e. it is the vector in 3D space that will be point up when projected on the screen. For this, the up vector must be perpendicular to the position-target axis. However, the MVS specification does not require that the provided up vector be perpendicular. This can be solved by a simple adjustment: \\(\\mathbf{u} _\\mathrm{adj} = \\mathrm{normalize} ( ((\\mathbf{t}-\\mathbf{p}) \\times \\mathbf{u}) \\times (\\mathbf{t}-\\mathbf{p}) )\\) Where \\(\\mathbf{u}\\) is the unadjusted up vector (the value in the MVS file), \\(\\mathbf{u} _\\mathrm{adj}\\) is the adjusted up vector, \\(\\mathbf{t}\\) is the target position, and \\(\\mathbf{p}\\) is the camera position (can be either reference or adjusted camera position, the result will be the same). If the up vector parameter is not provided, the default value ([0, 1, 0]) will be used (after adjustment). focus node The other way to adjust camera is to use a focus node. This node is placed as a child of a component node and instructs to set focus to the parent component (zoom in). This means that the camera target should be set to the center of the bounding sphere of the component, and the camera position should be set so that the bounding sphere just fits into view (vertically and horizontally). By default, the camera will be oriented so that the X axis points right, the Y axis points up, and the Z axis points towards the observer. This orientation can be changed using the optional vector parameters direction and up (see MVS tree schema ). The direction vector describes the direction from the camera position towards the target position (default [0, 0, -1]). The meaning of the up vector is the same as for the camera node and the same adjustment applies to it (default [0, 1, 0]). The reference camera position for a focus node can be calculated as follows: \\(\\mathbf{p} _\\mathrm{ref} = \\mathbf{t} - \\mathrm{normalize}(\\mathbf{d}) \\cdot 2 r \\cdot \\max(1, \\frac{h}{w})\\) Where \\(\\mathbf{t}\\) is the target position (center of the bounding sphere of the component), \\(r\\) is the radius of the bounding sphere of the component, \\(\\mathbf{d}\\) is the direction vector, \\(h\\) is the height of the viewport, \\(w\\) is the width of the viewport, and \\(\\mathbf{p} _\\mathrm{ref}\\) is the reference camera position (see explanation above). The following image illustrates the camera position calculation to fit the bounding sphere of a structure: Applying the FOV-adjustment formulas from the previous section, we can easily calculate the real position that we have to set to the camera ( \\(\\mathbf{p} _\\mathrm{adj}\\) ): For perspective projection: \\(\\mathbf{p} _\\mathrm{adj} = \\mathbf{t} - \\mathrm{normalize}(\\mathbf{d}) \\cdot \\frac{r}{\\sin(\\alpha/2)} \\cdot \\max(1, \\frac{h}{w})\\) For orthographic projection: \\(\\mathbf{p} _\\mathrm{adj} = \\mathbf{t} - \\mathrm{normalize}(\\mathbf{d}) \\cdot \\frac{r}{\\tan(\\alpha/2)} \\cdot \\max(1, \\frac{h}{w})\\) canvas node Attributes that apply to the MVS view as a whole, but are not related to camera positioning, can be set using a canvas node. This node is placed as a child of the root node (see MVS tree schema ). Currently, this only includes one parameter: background_color . Its value can be set to either a X11 color (e.g. \"red\" ), or a hexadecimal color code (e.g. \"#FF0011\" ). If there is no canvas node, the background will be white.","title":"Camera Settings"},{"location":"camera-settings/#mvs-camera-settings","text":"Camera position and orientation in MVS views can be adjusted in two ways: using a camera node or a focus node. Global attributes of the MVS view unrelated to camera positioning can be adjusted via a canvas node.","title":"MVS camera settings"},{"location":"camera-settings/#camera-node","text":"This node instructs to directly set the camera position and orientation. This is done by passing target , position , and optional up vector. The camera node is placed as a child of the root node (see MVS tree schema ). However, if the target and position vectors were interpreted directly, the resulting view would wildly depend on the camera field of view (FOV). For example, assume we have a sphere with center in the point [0,0,0] and radius 10 Angstroms, and we set target=[0,0,0] and position=[0,0,20] . With a camera with vertical FOV=90\u00b0, the sphere will fit into the camera's view nicely, with some margin above and under the sphere. But with a camera with vertical FOV=30\u00b0, the top and bottom of sphere will be cropped. To avoid these differences, MVS always uses position of a \"reference camera\" instead of the real camera position. We define the \"reference camera\" as a camera with such FOV that a sphere with radius R viewed from distance 2 R (from the center of the sphere) will just fit into view (i.e. there will be no margin but the sphere will not be cropped). This happens to be FOV = 2 arcsin(1/2) = 60\u00b0 for perspective projection, and FOV = 2 arctan(1/2) \u2248 53\u00b0 for orthographic projection. When using perspective projection, the real camera distance from target and the real camera position can be calculated using these formulas: \\(d _\\mathrm{adj} = d _\\mathrm{ref} \\cdot \\frac{1}{2 \\sin(\\alpha/2)}\\) \\(\\mathbf{p} _\\mathrm{adj} = \\mathbf{t} + (\\mathbf{p} _\\mathrm{ref} - \\mathbf{t}) \\cdot \\frac{1}{2 \\sin(\\alpha/2)}\\) Where \\(\\alpha\\) is the vertical FOV of the real camera, \\(d _\\mathrm{ref}\\) is the reference camera distance from target, \\(d _\\mathrm{adj}\\) is the real (adjusted) camera distance from target, \\(\\mathbf{t}\\) is the target position, \\(\\mathbf{p} _\\mathrm{ref}\\) is the reference camera position (the value in the MVS file), and \\(\\mathbf{p} _\\mathrm{adj}\\) is the real (adjusted) camera position. When using orthographic projection, the formulas are slightly different: \\(d _\\mathrm{adj} = d _\\mathrm{ref} \\cdot \\frac{1}{2 \\tan(\\alpha/2)}\\) \\(\\mathbf{p} _\\mathrm{adj} = \\mathbf{t} + (\\mathbf{p} _\\mathrm{ref} - \\mathbf{t}) \\cdot \\frac{1}{2 \\tan(\\alpha/2)}\\) The following image illustrates the camera position adjustment (left: reference camera with FOV=60\u00b0, right: real camera with FOV=30\u00b0 must be positioned further from the target to obtain a similar view): Using the example above ( target=[0,0,0] and position=[0,0,20] ), we can calculate that the real camera position will have to be set to: [0, 0, 14.14] for FOV=90\u00b0 (perspective projection) [0, 0, 20] for FOV=60\u00b0 (perspective projection) [0, 0, 38.68] for FOV=30\u00b0 (perspective projection) Note that for orthographic projection this adjustment achieves that the resulting view does not depend on the FOV value. For perspective projection, this is not possible and there will always be some \"fisheye effect\", but still it greatly reduces the dependence on FOV and avoids the too-much-zoomed-in and too-much-zoomed-out views when FOV changes. The up vector describes how the camera should be rotated around the position-target axis, i.e. it is the vector in 3D space that will be point up when projected on the screen. For this, the up vector must be perpendicular to the position-target axis. However, the MVS specification does not require that the provided up vector be perpendicular. This can be solved by a simple adjustment: \\(\\mathbf{u} _\\mathrm{adj} = \\mathrm{normalize} ( ((\\mathbf{t}-\\mathbf{p}) \\times \\mathbf{u}) \\times (\\mathbf{t}-\\mathbf{p}) )\\) Where \\(\\mathbf{u}\\) is the unadjusted up vector (the value in the MVS file), \\(\\mathbf{u} _\\mathrm{adj}\\) is the adjusted up vector, \\(\\mathbf{t}\\) is the target position, and \\(\\mathbf{p}\\) is the camera position (can be either reference or adjusted camera position, the result will be the same). If the up vector parameter is not provided, the default value ([0, 1, 0]) will be used (after adjustment).","title":"camera node"},{"location":"camera-settings/#focus-node","text":"The other way to adjust camera is to use a focus node. This node is placed as a child of a component node and instructs to set focus to the parent component (zoom in). This means that the camera target should be set to the center of the bounding sphere of the component, and the camera position should be set so that the bounding sphere just fits into view (vertically and horizontally). By default, the camera will be oriented so that the X axis points right, the Y axis points up, and the Z axis points towards the observer. This orientation can be changed using the optional vector parameters direction and up (see MVS tree schema ). The direction vector describes the direction from the camera position towards the target position (default [0, 0, -1]). The meaning of the up vector is the same as for the camera node and the same adjustment applies to it (default [0, 1, 0]). The reference camera position for a focus node can be calculated as follows: \\(\\mathbf{p} _\\mathrm{ref} = \\mathbf{t} - \\mathrm{normalize}(\\mathbf{d}) \\cdot 2 r \\cdot \\max(1, \\frac{h}{w})\\) Where \\(\\mathbf{t}\\) is the target position (center of the bounding sphere of the component), \\(r\\) is the radius of the bounding sphere of the component, \\(\\mathbf{d}\\) is the direction vector, \\(h\\) is the height of the viewport, \\(w\\) is the width of the viewport, and \\(\\mathbf{p} _\\mathrm{ref}\\) is the reference camera position (see explanation above). The following image illustrates the camera position calculation to fit the bounding sphere of a structure: Applying the FOV-adjustment formulas from the previous section, we can easily calculate the real position that we have to set to the camera ( \\(\\mathbf{p} _\\mathrm{adj}\\) ): For perspective projection: \\(\\mathbf{p} _\\mathrm{adj} = \\mathbf{t} - \\mathrm{normalize}(\\mathbf{d}) \\cdot \\frac{r}{\\sin(\\alpha/2)} \\cdot \\max(1, \\frac{h}{w})\\) For orthographic projection: \\(\\mathbf{p} _\\mathrm{adj} = \\mathbf{t} - \\mathrm{normalize}(\\mathbf{d}) \\cdot \\frac{r}{\\tan(\\alpha/2)} \\cdot \\max(1, \\frac{h}{w})\\)","title":"focus node"},{"location":"camera-settings/#canvas-node","text":"Attributes that apply to the MVS view as a whole, but are not related to camera positioning, can be set using a canvas node. This node is placed as a child of the root node (see MVS tree schema ). Currently, this only includes one parameter: background_color . Its value can be set to either a X11 color (e.g. \"red\" ), or a hexadecimal color code (e.g. \"#FF0011\" ). If there is no canvas node, the background will be white.","title":"canvas node"},{"location":"demos/","text":"Demonstrations The following demos showcase how MolViewSpec helps with creating interactive stories and visualizations. MolViewSpec Stories The combination of MolViewSpec and Mol* makes it easy to define engaging, interactive molecular stories, as showcased with the following two examples. Their source code can be found here . MolViewSpec Story: ABL Kinase BCR-ABL is a classic case of how structural biology can drive drug discovery. This story will help you understand the role of BCR-ABL in chronic myeloid leukemia and how the drug Imatinib works. MolViewSpec Story: TATA-Binding Protein Specialized DNA sequences next to genes, called promoters, define the proper start site and direction for transcription. In eukaryotic cells, a complex promoter system ensures that the proper RNA polymerase is targeted to each gene. The TATA-binding protein (TBP) is the central element of this system. I/HM Restraints Visualize structural restraints for integrated hybrid models (I/HM). The source code can be found here .","title":"Demos"},{"location":"demos/#demonstrations","text":"The following demos showcase how MolViewSpec helps with creating interactive stories and visualizations.","title":"Demonstrations"},{"location":"demos/#molviewspec-stories","text":"The combination of MolViewSpec and Mol* makes it easy to define engaging, interactive molecular stories, as showcased with the following two examples. Their source code can be found here .","title":"MolViewSpec Stories"},{"location":"demos/#molviewspec-story-abl-kinase","text":"BCR-ABL is a classic case of how structural biology can drive drug discovery. This story will help you understand the role of BCR-ABL in chronic myeloid leukemia and how the drug Imatinib works.","title":"MolViewSpec Story: ABL Kinase"},{"location":"demos/#molviewspec-story-tata-binding-protein","text":"Specialized DNA sequences next to genes, called promoters, define the proper start site and direction for transcription. In eukaryotic cells, a complex promoter system ensures that the proper RNA polymerase is targeted to each gene. The TATA-binding protein (TBP) is the central element of this system.","title":"MolViewSpec Story: TATA-Binding Protein"},{"location":"demos/#ihm-restraints","text":"Visualize structural restraints for integrated hybrid models (I/HM). The source code can be found here .","title":"I/HM Restraints"},{"location":"primitives/","text":"MolViewSpec primitives MolViewSpec supports geometric primitives such as circles, arrows, tubes etc. These can be freely added to scenes as needed and provide a powerful tool to add custom annotations. Primitives usually require that one or more positions are defined, which can be done by providing 3D vectors or by leveraging Selectors . Selectors can reference the position of specific atoms or residues without requiring you to manually obtain their 3D coordinates. Custom visuals using 3D vectors Acquire a builder instance as usual. Call .primitives to enter the primitives mode and start defining one or more geometric shapes. You can customize the visuals of all primitives at this stage as well and make e.g. everything semi-transparent. builder = create_builder () builder . primitives ( opacity = 0.66 ) A range of functions are available to define: mesh | lines | tube | arrow | distance | angle | label | ellipse | ellipsoid | sphere | box . Most of them expect positions to be provided to define start and end point or the direction/orientation of a shape. Each shape can be further customized using representation-specific parameters. . arrow ( start = ( 1 , 1 , 1 ), direction = ( 0 , 2.2 , 0 ), tube_radius = 0.05 , show_end_cap = True , color = \"#ff00ff\" , tooltip = \"Y\" , ) Combining primitives with ComponentExpression selections Selectors are compatible with this part of the API, allowing you to reference the spatial coordinates of parts of a structure without the need of obtaining their 3D positional data explicitly. The following example showcases how a ComponentExpression is used to defined start and end point of a distance measurement that will add a dashed length between both referenced residues and label it with the computed distance between the two residues. builder = create_builder () structure = builder . download ( url = _url_for_mmcif ( \"1tqn\" )) . parse ( format = \"mmcif\" ) . model_structure () ( structure . component ( selector = \"polymer\" ) . representation () . color ( color = \"blue\" )) ( structure . component ( selector = [ ComponentExpression ( auth_seq_id = 258 ), ComponentExpression ( auth_seq_id = 508 )]) . representation ( type = \"ball_and_stick\" ) . color ( color = \"green\" ) ) The following snippet creates primitives in the context of this structure. structure . primitives () . distance ( start = ComponentExpression ( auth_seq_id = 258 ), end = ComponentExpression ( auth_seq_id = 508 ), color = \"red\" , radius = 0.1 , dash_length = 0.1 , label_template = \"Distance: {{distance}}\" , label_color = \"red\" , ) Using references More complex cases will involve multiple structures. ComponentExpression can be tied to specific structures using explicit references. This allows e.g. to distance measurements between two distinct structures. This example loads two structures: 1tqn and 1cbs. Note the .model_structure(ref=\"X\") invocations that assign a user-defined reference to each structures. This allows pointing to these structures as X and Y when defining primitives using Selectors. builder = create_builder () _1tqn = builder . download ( url = _url_for_mmcif ( \"1tqn\" )) . parse ( format = \"mmcif\" ) . model_structure ( ref = \"X\" ) _1tqn . component ( selector = \"polymer\" ) . representation () . color ( color = \"blue\" ) ( _1tqn . component ( selector = ComponentExpression ( auth_seq_id = 508 )) . representation ( type = \"ball_and_stick\" ) . color ( color = \"green\" ) ) _1cbs = builder . download ( url = _url_for_mmcif ( \"1cbs\" )) . parse ( format = \"mmcif\" ) . model_structure ( ref = \"Y\" ) _1cbs . component ( selector = \"polymer\" ) . representation () . color ( color = \"blue\" ) ( _1cbs . component ( selector = ComponentExpression ( auth_seq_id = 200 )) . representation ( type = \"ball_and_stick\" ) . color ( color = \"green\" ) ) Now, individual sequence positions can be used as value for the start and end position of this distance measurement despite them coming from separate structures. ( builder . primitives () . distance ( start = PrimitiveComponentExpressions ( structure_ref = \"X\" , expressions = [ ComponentExpression ( auth_seq_id = 508 )]), end = PrimitiveComponentExpressions ( structure_ref = \"Y\" , expressions = [ ComponentExpression ( auth_seq_id = 200 )]), color = \"purple\" , radius = 1 , dash_length = 1 , label_template = \"Ligand Distance: {{distance}}\" , label_color = \"red\" , ) )","title":"Primitives"},{"location":"primitives/#molviewspec-primitives","text":"MolViewSpec supports geometric primitives such as circles, arrows, tubes etc. These can be freely added to scenes as needed and provide a powerful tool to add custom annotations. Primitives usually require that one or more positions are defined, which can be done by providing 3D vectors or by leveraging Selectors . Selectors can reference the position of specific atoms or residues without requiring you to manually obtain their 3D coordinates.","title":"MolViewSpec primitives"},{"location":"primitives/#custom-visuals-using-3d-vectors","text":"Acquire a builder instance as usual. Call .primitives to enter the primitives mode and start defining one or more geometric shapes. You can customize the visuals of all primitives at this stage as well and make e.g. everything semi-transparent. builder = create_builder () builder . primitives ( opacity = 0.66 ) A range of functions are available to define: mesh | lines | tube | arrow | distance | angle | label | ellipse | ellipsoid | sphere | box . Most of them expect positions to be provided to define start and end point or the direction/orientation of a shape. Each shape can be further customized using representation-specific parameters. . arrow ( start = ( 1 , 1 , 1 ), direction = ( 0 , 2.2 , 0 ), tube_radius = 0.05 , show_end_cap = True , color = \"#ff00ff\" , tooltip = \"Y\" , )","title":"Custom visuals using 3D vectors"},{"location":"primitives/#combining-primitives-with-componentexpression-selections","text":"Selectors are compatible with this part of the API, allowing you to reference the spatial coordinates of parts of a structure without the need of obtaining their 3D positional data explicitly. The following example showcases how a ComponentExpression is used to defined start and end point of a distance measurement that will add a dashed length between both referenced residues and label it with the computed distance between the two residues. builder = create_builder () structure = builder . download ( url = _url_for_mmcif ( \"1tqn\" )) . parse ( format = \"mmcif\" ) . model_structure () ( structure . component ( selector = \"polymer\" ) . representation () . color ( color = \"blue\" )) ( structure . component ( selector = [ ComponentExpression ( auth_seq_id = 258 ), ComponentExpression ( auth_seq_id = 508 )]) . representation ( type = \"ball_and_stick\" ) . color ( color = \"green\" ) ) The following snippet creates primitives in the context of this structure. structure . primitives () . distance ( start = ComponentExpression ( auth_seq_id = 258 ), end = ComponentExpression ( auth_seq_id = 508 ), color = \"red\" , radius = 0.1 , dash_length = 0.1 , label_template = \"Distance: {{distance}}\" , label_color = \"red\" , )","title":"Combining primitives with ComponentExpression selections"},{"location":"primitives/#using-references","text":"More complex cases will involve multiple structures. ComponentExpression can be tied to specific structures using explicit references. This allows e.g. to distance measurements between two distinct structures. This example loads two structures: 1tqn and 1cbs. Note the .model_structure(ref=\"X\") invocations that assign a user-defined reference to each structures. This allows pointing to these structures as X and Y when defining primitives using Selectors. builder = create_builder () _1tqn = builder . download ( url = _url_for_mmcif ( \"1tqn\" )) . parse ( format = \"mmcif\" ) . model_structure ( ref = \"X\" ) _1tqn . component ( selector = \"polymer\" ) . representation () . color ( color = \"blue\" ) ( _1tqn . component ( selector = ComponentExpression ( auth_seq_id = 508 )) . representation ( type = \"ball_and_stick\" ) . color ( color = \"green\" ) ) _1cbs = builder . download ( url = _url_for_mmcif ( \"1cbs\" )) . parse ( format = \"mmcif\" ) . model_structure ( ref = \"Y\" ) _1cbs . component ( selector = \"polymer\" ) . representation () . color ( color = \"blue\" ) ( _1cbs . component ( selector = ComponentExpression ( auth_seq_id = 200 )) . representation ( type = \"ball_and_stick\" ) . color ( color = \"green\" ) ) Now, individual sequence positions can be used as value for the start and end position of this distance measurement despite them coming from separate structures. ( builder . primitives () . distance ( start = PrimitiveComponentExpressions ( structure_ref = \"X\" , expressions = [ ComponentExpression ( auth_seq_id = 508 )]), end = PrimitiveComponentExpressions ( structure_ref = \"Y\" , expressions = [ ComponentExpression ( auth_seq_id = 200 )]), color = \"purple\" , radius = 1 , dash_length = 1 , label_template = \"Ligand Distance: {{distance}}\" , label_color = \"red\" , ) )","title":"Using references"},{"location":"selectors/","text":"MolViewSpec selectors Selectors are used in MVS to define substructures (components) and apply colors, labels, or tooltips to them. MVS nodes that take a selector parameter are component (creates a component from the parent structure node) and color (applies coloring to a part of the parent representation node). There are three kinds of selectors: Static selector is a string that selects a part of the structure based on entity type. The supported static selectors are these: \"all\", \"polymer\", \"protein\", \"nucleic\", \"branched\", \"ligand\", \"ion\", \"water\" Component expression is an object that selects a set of atoms based on their properties like chain identifier, residue number, or type symbol. The type of a component expression object is: { label_entity_id? : str , // Entity identifier label_asym_id? : str , // Chain identifier in label_* numbering auth_asym_id? : str , // Chain identifier in auth_* numbering label_seq_id? : int , // Residue number in label_* numbering auth_seq_id? : int , // Residue number in auth_* numbering pdbx_PDB_ins_code? : str , // PDB insertion code beg_label_seq_id? : int , // Minimum label_seq_id (inclusive), leave blank to start from the beginning of the chain end_label_seq_id? : int , // Maximum label_seq_id (inclusive), leave blank to go to the end of the chain beg_auth_seq_id? : int , // Minimum auth_seq_id (inclusive), leave blank to start from the beginning of the chain end_auth_seq_id? : int , // Maximum auth_seq_id (inclusive), leave blank to go to the end of the chain label_atom_id? : str , // Atom name like 'CA', 'N', 'O', in label_* numbering auth_atom_id? : str , // Atom name like 'CA', 'N', 'O', in auth_* numbering type_symbol? : str , // Element symbol like 'H', 'HE', 'LI', 'BE' atom_id? : int , // Unique atom identifier (_atom_site.id) atom_index? : int , // 0-based index of the atom in the source data } A component expression can include any combination of the fields. An expression with multiple fields selects atoms that fulfill all fields at the same time. Examples: // Select whole chain A selector : { label_asym_id : 'A' } // Select residues 100 to 200 (inclusive) in chain B selector : { label_asym_id : 'B' , beg_label_seq_id : 100 , end_label_seq_id : 200 } // Select C-alpha atoms in residue 100 (using auth_* numbering) of any chain selector : { auth_seq_id : 100 , type_symbol : 'C' , auth_atom_id : 'CA' } Union component expression is an array of simple component expressions. A union component expression is interpreted as set union, i.e. it selects all atoms that fulfill at least one of the expressions in the array. Example: // Select chains A, B, and C selector : [{ label_asym_id : 'A' }, { label_asym_id : 'B' }, { label_asym_id : 'C' }]; // Select residues up to 100 (inclusive) in chain A plus all magnesium atoms selector : [{ label_asym_id : 'A' , end_label_seq_id : 100 }, { type_symbol : 'MG' }]; Component expressions can be applied to primitives as well. Furthermore, a ref can be provided to make selections with a specific node when working e.g. with multiple structures. Any MVS node allows you to set an anchor: builder.download(url=url).parse(format=\"mmcif\").model_structure(ref=\"X\") This ref can then be referenced in the context of a selection: PrimitiveComponentExpressions(structure_ref=\"X\", expressions=[ComponentExpression(auth_seq_id=508)]) An alternative to using selectors is using MVS annotations . This means defining the selections in a separate file and referencing them from the MVS file.","title":"Selectors"},{"location":"selectors/#molviewspec-selectors","text":"Selectors are used in MVS to define substructures (components) and apply colors, labels, or tooltips to them. MVS nodes that take a selector parameter are component (creates a component from the parent structure node) and color (applies coloring to a part of the parent representation node). There are three kinds of selectors: Static selector is a string that selects a part of the structure based on entity type. The supported static selectors are these: \"all\", \"polymer\", \"protein\", \"nucleic\", \"branched\", \"ligand\", \"ion\", \"water\" Component expression is an object that selects a set of atoms based on their properties like chain identifier, residue number, or type symbol. The type of a component expression object is: { label_entity_id? : str , // Entity identifier label_asym_id? : str , // Chain identifier in label_* numbering auth_asym_id? : str , // Chain identifier in auth_* numbering label_seq_id? : int , // Residue number in label_* numbering auth_seq_id? : int , // Residue number in auth_* numbering pdbx_PDB_ins_code? : str , // PDB insertion code beg_label_seq_id? : int , // Minimum label_seq_id (inclusive), leave blank to start from the beginning of the chain end_label_seq_id? : int , // Maximum label_seq_id (inclusive), leave blank to go to the end of the chain beg_auth_seq_id? : int , // Minimum auth_seq_id (inclusive), leave blank to start from the beginning of the chain end_auth_seq_id? : int , // Maximum auth_seq_id (inclusive), leave blank to go to the end of the chain label_atom_id? : str , // Atom name like 'CA', 'N', 'O', in label_* numbering auth_atom_id? : str , // Atom name like 'CA', 'N', 'O', in auth_* numbering type_symbol? : str , // Element symbol like 'H', 'HE', 'LI', 'BE' atom_id? : int , // Unique atom identifier (_atom_site.id) atom_index? : int , // 0-based index of the atom in the source data } A component expression can include any combination of the fields. An expression with multiple fields selects atoms that fulfill all fields at the same time. Examples: // Select whole chain A selector : { label_asym_id : 'A' } // Select residues 100 to 200 (inclusive) in chain B selector : { label_asym_id : 'B' , beg_label_seq_id : 100 , end_label_seq_id : 200 } // Select C-alpha atoms in residue 100 (using auth_* numbering) of any chain selector : { auth_seq_id : 100 , type_symbol : 'C' , auth_atom_id : 'CA' } Union component expression is an array of simple component expressions. A union component expression is interpreted as set union, i.e. it selects all atoms that fulfill at least one of the expressions in the array. Example: // Select chains A, B, and C selector : [{ label_asym_id : 'A' }, { label_asym_id : 'B' }, { label_asym_id : 'C' }]; // Select residues up to 100 (inclusive) in chain A plus all magnesium atoms selector : [{ label_asym_id : 'A' , end_label_seq_id : 100 }, { type_symbol : 'MG' }]; Component expressions can be applied to primitives as well. Furthermore, a ref can be provided to make selections with a specific node when working e.g. with multiple structures. Any MVS node allows you to set an anchor: builder.download(url=url).parse(format=\"mmcif\").model_structure(ref=\"X\") This ref can then be referenced in the context of a selection: PrimitiveComponentExpressions(structure_ref=\"X\", expressions=[ComponentExpression(auth_seq_id=508)]) An alternative to using selectors is using MVS annotations . This means defining the selections in a separate file and referencing them from the MVS file.","title":"MolViewSpec selectors"},{"location":"tree-schema/","text":"MolViewSpec tree schema v1 This is the exhaustive list of MolViewSpec node kinds, their parameters, and parent-child relationships. Parameters with ?: are optional, i.e. they may be omitted, meaning that the default value should be used. Parameters with : are required, i.e. omitting them will result in an invalid MolViewSpec tree. This specification is formalized by the OpenAPI JSON schema . (This document was auto-generated by node lib/commonjs/cli/mvs/mvs-print-schema --markdown in Mol*.) root [Root of the tree must be of this kind] Auxiliary node kind that only appears as the tree root. Parent: none Params: download This node instructs to retrieve a data resource. Parent: root Params: url: string URL of the data resource. parse This node instructs to parse a data resource. Parent: download Params: format: \"mmcif\" | \"bcif\" | \"pdb\" | \"map\" Format of the input data resource. structure This node instructs to create a structure from a parsed data resource. \"Structure\" refers to an internal representation of molecular coordinates without any visual representation. Parent: parse Params: type: \"model\" | \"assembly\" | \"symmetry\" | \"symmetry_mates\" Type of structure to be created ( \"model\" for original model coordinates, \"assembly\" for assembly structure, \"symmetry\" for a set of crystal unit cells based on Miller indices, \"symmetry_mates\" for a set of asymmetric units within a radius from the original model). block_header?: string | null Header of the CIF block to read coordinates from (only applies when the input data are from CIF or BinaryCIF). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read coordinates from (only applies when the input data are from CIF or BinaryCIF and block_header is null ). Default: 0 model_index?: Integer 0-based index of model in case the input data contain multiple models. Default: 0 assembly_id?: string | null Assembly identifier (only applies when kind is \"assembly\" ). If null , the first assembly is selected. Default: null radius?: number Distance (in Angstroms) from the original model in which asymmetric units should be included (only applies when kind is \"symmetry_mates\" ). Default: 5 ijk_min?: [Integer, Integer, Integer] Miller indices of the bottom-left unit cell to be included (only applies when kind is \"symmetry\" ). Default: [-1, -1, -1] ijk_max?: [Integer, Integer, Integer] Miller indices of the top-right unit cell to be included (only applies when kind is \"symmetry\" ). Default: [1, 1, 1] transform This node instructs to rotate and/or translate structure coordinates. Parent: structure Params: rotation?: Array<number> Rotation matrix (3x3 matrix flattened in column major format (j*3+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. The default value is the identity matrix (corresponds to no rotation). Default: [1, 0, 0, 0, 1, 0, 0, 0, 1] translation?: [number, number, number] Translation vector, applied to the structure coordinates after rotation. The default value is the zero vector (corresponds to no translation). Default: [0, 0, 0] component This node instructs to create a component (i.e. a subset of the parent structure). Parent: structure Params: selector: (\"all\" | \"polymer\" | \"protein\" | \"nucleic\" | \"branched\" | \"ligand\" | \"ion\" | \"water\" | \"coarse\") | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> Defines what part of the parent structure should be included in this component. component_from_uri This node instructs to create a component defined by an external annotation resource. Parent: structure Params: uri: string URL of the annotation resource. format: \"cif\" | \"bcif\" | \"json\" Format of the annotation resource. schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" and block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the component identifier. Default: \"component\" field_values?: Array<string> | null List of component identifiers (i.e. values in the field given by field_name ) which should be included in this component. If null , component identifiers are ignored (all annotation rows are included), and field_name field can be dropped from the annotation. Default: null component_from_source This node instructs to create a component defined by an annotation resource included in the same file this structure was loaded from. Only applicable if the structure was loaded from an mmCIF or BinaryCIF file. Parent: structure Params: schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from. If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from. If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the component identifier. Default: \"component\" field_values?: Array<string> | null List of component identifiers (i.e. values in the field given by field_name ) which should be included in this component. If null , component identifiers are ignored (all annotation rows are included), and field_name field can be dropped from the annotation. Default: null representation This node instructs to create a visual representation of a component. Parent: component or component_from_uri or component_from_source Params: type: cartoon | ball_and_stick | spacefill | carbohydrate | surface Representation type [This parameter determines the rest of parameters] Case type: \"cartoon\" : size_factor?: number Scales the corresponding visuals. Default: 1 tubular_helices?: boolean Simplify corkscrew helices to tubes. Default: false Case type: \"ball_and_stick\" : size_factor?: number Scales the corresponding visuals. Default: 1 ignore_hydrogens?: boolean Controls whether hydrogen atoms are drawn. Default: false Case type: \"spacefill\" : size_factor?: number Scales the corresponding visuals. Default: 1 ignore_hydrogens?: boolean Controls whether hydrogen atoms are drawn. Default: false Case type: \"carbohydrate\" : size_factor?: number Scales the corresponding visuals. Default: 1 Case type: \"surface\" : size_factor?: number Scales the corresponding visuals. Default: 1 ignore_hydrogens?: boolean Controls whether hydrogen atoms are drawn. Default: false volume This node instructs to create a volume from a parsed data resource. \"Volume\" refers to an internal representation of volumetric data without any visual representation. Parent: parse Params: channel_id?: string | null Channel identifier (only applies when the input data contain multiple channels). Default: null volume_representation This node instructs to create a visual representation of a volume. Parent: volume Params: type: isosurface Representation type [This parameter determines the rest of parameters] Case type: \"isosurface\" : relative_isovalue?: number | null Relative isovalue. Default: null absolute_isovalue?: number | null Absolute isovalue. Overrides relative_isovalue . Default: null show_wireframe?: boolean Show mesh wireframe. Defaults to false. Default: false show_faces?: boolean Show mesh faces. Defaults to true. Default: true color This node instructs to apply color to a visual representation. Parent: representation or volume_representation Params: color?: ColorName | HexColor Color to apply to the representation. Can be either an X11 color name (e.g. \"red\" ) or a hexadecimal code (e.g. \"#FF0011\" ). Default: \"white\" selector?: (\"all\" | \"polymer\" | \"protein\" | \"nucleic\" | \"branched\" | \"ligand\" | \"ion\" | \"water\" | \"coarse\") | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> Defines to what part of the representation this color should be applied. Default: \"all\" color_from_uri This node instructs to apply colors to a visual representation. The colors are defined by an external annotation resource. Parent: representation Params: uri: string URL of the annotation resource. format: \"cif\" | \"bcif\" | \"json\" Format of the annotation resource. schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" and block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the color. Default: \"color\" color_from_source This node instructs to apply colors to a visual representation. The colors are defined by an annotation resource included in the same file this structure was loaded from. Only applicable if the structure was loaded from an mmCIF or BinaryCIF file. Parent: representation Params: schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from. If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from. If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the color. Default: \"color\" opacity This node instructs to apply opacity/transparency to a visual representation. Parent: representation or volume_representation Params: opacity: number Opacity of a representation. 0.0: fully transparent, 1.0: fully opaque. label This node instructs to add a label (textual visual representation) to a component. Parent: component or component_from_uri or component_from_source Params: text: string Content of the shown label. label_from_uri This node instructs to add labels (textual visual representations) to parts of a structure. The labels are defined by an external annotation resource. Parent: structure Params: uri: string URL of the annotation resource. format: \"cif\" | \"bcif\" | \"json\" Format of the annotation resource. schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" and block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the label text. Default: \"label\" label_from_source This node instructs to add labels (textual visual representations) to parts of a structure. The labels are defined by an annotation resource included in the same file this structure was loaded from. Only applicable if the structure was loaded from an mmCIF or BinaryCIF file. Parent: structure Params: schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from. If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from. If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the label text. Default: \"label\" tooltip This node instructs to add a tooltip to a component. \"Tooltip\" is a text which is not a part of the visualization but should be presented to the users when they interact with the component (typically, the tooltip will be shown somewhere on the screen when the user hovers over a visual representation of the component). Parent: component or component_from_uri or component_from_source Params: text: string Content of the shown tooltip. tooltip_from_uri This node instructs to add tooltips to parts of a structure. The tooltips are defined by an external annotation resource. Parent: structure Params: uri: string URL of the annotation resource. format: \"cif\" | \"bcif\" | \"json\" Format of the annotation resource. schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" and block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the tooltip text. Default: \"tooltip\" tooltip_from_source This node instructs to add tooltips to parts of a structure. The tooltips are defined by an annotation resource included in the same file this structure was loaded from. Only applicable if the structure was loaded from an mmCIF or BinaryCIF file. Parent: structure Params: schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from. If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from. If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the tooltip text. Default: \"tooltip\" focus This node instructs to set the camera focus to a component (zoom in). Parent: root or component or component_from_uri or component_from_source or primitives or primitives_from_uri or volume or volume_representation Params: direction?: [number, number, number] Vector describing the direction of the view (camera position -> focused target). Default: [0, 0, -1] up?: [number, number, number] Vector which will be aligned with the screen Y axis. Default: [0, 1, 0] radius?: number | null Radius of the focused sphere (overrides radius_factor and radius_extra ). Default: null radius_factor?: number Radius of the focused sphere relative to the radius of parent component (default: 1). Focused radius = component_radius * radius_factor + radius_extent. Default: 1 radius_extent?: number Addition to the radius of the focused sphere, if computed from the radius of parent component (default: 0). Focused radius = component_radius * radius_factor + radius_extent. Default: 0 camera This node instructs to set the camera position and orientation. Parent: root Params: target: [number, number, number] Coordinates of the point in space at which the camera is pointing. position: [number, number, number] Coordinates of the camera. up?: [number, number, number] Vector which will be aligned with the screen Y axis. Default: [0, 1, 0] canvas This node sets canvas properties. Parent: root Params: background_color: ColorName | HexColor Color of the canvas background. Can be either an X11 color name (e.g. \"red\" ) or a hexadecimal code (e.g. \"#FF0011\" ). primitives This node groups a list of geometrical primitives Parent: structure or root Params: color?: ColorName | HexColor Default color for primitives in this group. Default: \"white\" label_color?: ColorName | HexColor Default label color for primitives in this group. Default: \"white\" tooltip?: string | null Default tooltip for primitives in this group. Default: null opacity?: number Opacity of primitive geometry in this group. Default: 1 label_opacity?: number Opacity of primitive labels in this group. Default: 1 instances?: Array<Array<number>> | null Instances of this primitive group defined as 4x4 column major (j * 4 + i indexing) transformation matrices. Default: null primitives_from_uri This node loads a list of primitives from URI Parent: structure or root Params: uri: string Location of the resource. format: \"mvs-node-json\" Format of the data. references?: Array<string> List of nodes the data are referencing. Default: [] primitive This node represents a geometrical primitive Parent: primitives Params: kind: mesh | lines | tube | arrow | distance_measurement | angle_measurement | label | ellipse | ellipsoid | box Kind of geometrical primitive [This parameter determines the rest of parameters] Case kind: \"mesh\" : vertices: Array<number> 3*n_vertices length array of floats with vertex position (x1, y1, z1, ...). indices: Array<Integer> 3*n_triangles length array of indices into vertices that form triangles (t1_1, t1_2, t1_3, ...). triangle_groups?: Array<Integer> | null Assign a number to each triangle to group them. If not specified, each triangle is considered a separate group (triangle i = group i). Default: null group_colors?: { [K in Integer]: (ColorName | HexColor) } Assign a color to each group. Where not assigned, uses color . Default: {} group_tooltips?: { [K in Integer]: string } Assign a tooltip to each group. Where not assigned, uses tooltip . Default: {} color?: (ColorName | HexColor) | null Color of the triangles and wireframe. Can be overwritten by group_colors . If not specified, uses the parent primitives group color . Default: null tooltip?: string | null Tooltip shown when hovering over the mesh. Can be overwritten by group_tooltips . If not specified, uses the parent primitives group tooltip . Default: null show_triangles?: boolean Determine whether to render triangles of the mesh. Default: true show_wireframe?: boolean Determine whether to render wireframe of the mesh. Default: false wireframe_width?: number Wireframe line width (in screen-space units). Default: 1 wireframe_color?: (ColorName | HexColor) | null Wireframe color. If not specified, uses group_colors . Default: null Case kind: \"lines\" : vertices: Array<number> 3*n_vertices length array of floats with vertex position (x1, y1, z1, ...). indices: Array<Integer> 2*n_lines length array of indices into vertices that form lines (l1_1, l1_2, ...). line_groups?: Array<Integer> | null Assign a number to each triangle to group them. If not specified, each line is considered a separate group (line i = group i). Default: null group_colors?: { [K in Integer]: (ColorName | HexColor) } Assign a color to each group. Where not assigned, uses color . Default: {} group_tooltips?: { [K in Integer]: string } Assign a tooltip to each group. Where not assigned, uses tooltip . Default: {} group_widths?: { [K in Integer]: number } Assign a line width to each group. Where not assigned, uses width . Default: {} color?: (ColorName | HexColor) | null Color of the lines. Can be overwritten by group_colors . If not specified, uses the parent primitives group color . Default: null tooltip?: string | null Tooltip shown when hovering over the lines. Can be overwritten by group_tooltips . If not specified, uses the parent primitives group tooltip . Default: null width?: number Line width (in screen-space units). Can be overwritten by group_widths . Default: 1 Case kind: \"tube\" : start: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Start point of the tube. end: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> End point of the tube. radius?: number Tube radius (in Angstroms). Default: 0.05 dash_length?: number | null Length of each dash and gap between dashes. If not specified (null), draw full line. Default: null color?: (ColorName | HexColor) | null Color of the tube. If not specified, uses the parent primitives group color . Default: null tooltip?: string | null Tooltip to show when hovering over the tube. If not specified, uses the parent primitives group tooltip . Default: null Case kind: \"arrow\" : start: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Start point of the arrow. end?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null End point of the arrow. Default: null direction?: [number, number, number] | null If specified, the endpoint is computed as start + direction. Default: null length?: number | null Length of the arrow. If unset, the distance between start and end is used. Default: null show_start_cap?: boolean Draw a cap at the start of the arrow. Default: false start_cap_length?: number Length of the start cap. Default: 0.1 start_cap_radius?: number Radius of the start cap. Default: 0.1 show_end_cap?: boolean Draw a cap at the end of the arrow. Default: false end_cap_length?: number Length of the end cap. Default: 0.1 end_cap_radius?: number Radius of the end cap. Default: 0.1 show_tube?: boolean Draw a tube connecting the start and end points. Default: true tube_radius?: number Tube radius (in Angstroms). Default: 0.05 tube_dash_length?: number | null Length of each dash and gap between dashes. If not specified (null), draw full line. Default: null color?: (ColorName | HexColor) | null Color of the tube. If not specified, uses the parent primitives group color . Default: null tooltip?: string | null Tooltip to show when hovering over the arrow. If not specified, uses the parent primitives group tooltip . Default: null Case kind: \"distance_measurement\" : start: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Start point of the tube. end: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> End point of the tube. radius?: number Tube radius (in Angstroms). Default: 0.05 dash_length?: number | null Length of each dash and gap between dashes. If not specified (null), draw full line. Default: null color?: (ColorName | HexColor) | null Color of the tube. If not specified, uses the parent primitives group color . Default: null label_template?: string Template used to construct the label. Use {{distance}} as placeholder for the distance. Default: \"{{distance}}\" label_size?: number | null Size of the label (text height in Angstroms). If not specified, size will be relative to the distance (see label_auto_size_scale, label_auto_size_min). Default: null label_auto_size_scale?: number Scaling factor for relative size. Default: 0.1 label_auto_size_min?: number Minimum size for relative size. Default: 0 label_color?: (ColorName | HexColor) | null Color of the label. If not specified, uses the parent primitives group label_color . Default: null Case kind: \"angle_measurement\" : a: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Point A. b: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Point B. c: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Point C. label_template?: string Template used to construct the label. Use {{angle}} as placeholder for the angle in radians. Default: \"{{angle}}\" label_size?: number | null Size of the label (text height in Angstroms). If not specified, size will be relative to the distance (see label_auto_size_scale, label_auto_size_min). Default: null label_auto_size_scale?: number Scaling factor for relative size. Default: 0.33 label_auto_size_min?: number Minimum size for relative size. Default: 0 label_color?: (ColorName | HexColor) | null Color of the label. If not specified, uses the parent primitives group label_color . Default: null show_vector?: boolean Draw vectors between (a, b) and (b, c). Default: true vector_color?: (ColorName | HexColor) | null Color of the vectors. Default: null show_section?: boolean Draw a filled circle section representing the angle. Default: true section_color?: (ColorName | HexColor) | null Color of the angle section. If not specified, the primitives group color is used. Default: null section_radius?: number | null Radius of the angle section. In angstroms. Default: null section_radius_scale?: number Factor to scale the radius of the angle section. Ignored if section_radius is set. Default: 0.33 Case kind: \"label\" : position: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Position of this label. text: string The label. label_size?: number Size of the label (text height in Angstroms). Default: 1 label_color?: (ColorName | HexColor) | null Color of the label. If not specified, uses the parent primitives group label_color . Default: null label_offset?: number Camera-facing offset to prevent overlap with geometry. Default: 0 Case kind: \"ellipse\" : color?: (ColorName | HexColor) | null Color of the ellipse. If not specified, uses the parent primitives group color . Default: null as_circle?: boolean If true, ignores radius_minor/magnitude of the minor axis. Default: false center: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> The center of the ellipse. major_axis?: [number, number, number] | null Major axis of this ellipse. Default: null minor_axis?: [number, number, number] | null Minor axis of this ellipse. Default: null major_axis_endpoint?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null Major axis endpoint. If specified, overrides major axis to be major_axis_endpoint - center. Default: null minor_axis_endpoint?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null Minor axis endpoint. If specified, overrides minor axis to be minor_axis_endpoint - center. Default: null radius_major?: number | null Radius of the major axis. If unset, the length of the major axis is used. Default: null radius_minor?: number | null Radius of the minor axis. If unset, the length of the minor axis is used. Default: null theta_start?: number Start of the arc. In radians Default: 0 theta_end?: number End of the arc. In radians Default: 6.283185307179586 tooltip?: string | null Tooltip to show when hovering over the tube. If not specified, uses the parent primitives group tooltip . Default: null Case kind: \"ellipsoid\" : color?: (ColorName | HexColor) | null Color of the ellipsoid. If not specified, uses the parent primitives group color . Default: null center: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> The center of the ellipsoid. major_axis?: [number, number, number] | null Major axis of this ellipsoid. Default: null minor_axis?: [number, number, number] | null Minor axis of this ellipsoid. Default: null major_axis_endpoint?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null Major axis endpoint. If specified, overrides major axis to be major_axis_endpoint - center. Default: null minor_axis_endpoint?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null Minor axis endpoint. If specified, overrides minor axis to be minor_axis_endpoint - center. Default: null radius?: ([number, number, number] | number) | null Radii of the ellipsoid along each axis. Default: null radius_extent?: ([number, number, number] | number) | null Added to the radii of the ellipsoid along each axis. Default: null tooltip?: string | null Tooltip to show when hovering over the tube. If not specified, uses the parent primitives group tooltip . Default: null Case kind: \"box\" : center: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> The center of the box. extent?: [number, number, number] | null The width, the height, and the depth of the box. Added to the bounding box determined by the center. Default: null show_faces?: boolean Determine whether to render the faces of the box. Default: true face_color?: (ColorName | HexColor) | null Color of the box faces. Default: null show_edges?: boolean Determine whether to render the edges of the box. Default: false edge_radius?: number Radius of the box edges. In angstroms. Default: 0.1 edge_color?: (ColorName | HexColor) | null Color of the edges. Default: null tooltip?: string | null Tooltip to show when hovering over the tube. If not specified, uses the parent primitives group tooltip . Default: null","title":"Tree Schema"},{"location":"tree-schema/#molviewspec-tree-schema-v1","text":"This is the exhaustive list of MolViewSpec node kinds, their parameters, and parent-child relationships. Parameters with ?: are optional, i.e. they may be omitted, meaning that the default value should be used. Parameters with : are required, i.e. omitting them will result in an invalid MolViewSpec tree. This specification is formalized by the OpenAPI JSON schema . (This document was auto-generated by node lib/commonjs/cli/mvs/mvs-print-schema --markdown in Mol*.)","title":"MolViewSpec tree schema v1"},{"location":"tree-schema/#root","text":"[Root of the tree must be of this kind] Auxiliary node kind that only appears as the tree root. Parent: none Params:","title":"root"},{"location":"tree-schema/#download","text":"This node instructs to retrieve a data resource. Parent: root Params: url: string URL of the data resource.","title":"download"},{"location":"tree-schema/#parse","text":"This node instructs to parse a data resource. Parent: download Params: format: \"mmcif\" | \"bcif\" | \"pdb\" | \"map\" Format of the input data resource.","title":"parse"},{"location":"tree-schema/#structure","text":"This node instructs to create a structure from a parsed data resource. \"Structure\" refers to an internal representation of molecular coordinates without any visual representation. Parent: parse Params: type: \"model\" | \"assembly\" | \"symmetry\" | \"symmetry_mates\" Type of structure to be created ( \"model\" for original model coordinates, \"assembly\" for assembly structure, \"symmetry\" for a set of crystal unit cells based on Miller indices, \"symmetry_mates\" for a set of asymmetric units within a radius from the original model). block_header?: string | null Header of the CIF block to read coordinates from (only applies when the input data are from CIF or BinaryCIF). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read coordinates from (only applies when the input data are from CIF or BinaryCIF and block_header is null ). Default: 0 model_index?: Integer 0-based index of model in case the input data contain multiple models. Default: 0 assembly_id?: string | null Assembly identifier (only applies when kind is \"assembly\" ). If null , the first assembly is selected. Default: null radius?: number Distance (in Angstroms) from the original model in which asymmetric units should be included (only applies when kind is \"symmetry_mates\" ). Default: 5 ijk_min?: [Integer, Integer, Integer] Miller indices of the bottom-left unit cell to be included (only applies when kind is \"symmetry\" ). Default: [-1, -1, -1] ijk_max?: [Integer, Integer, Integer] Miller indices of the top-right unit cell to be included (only applies when kind is \"symmetry\" ). Default: [1, 1, 1]","title":"structure"},{"location":"tree-schema/#transform","text":"This node instructs to rotate and/or translate structure coordinates. Parent: structure Params: rotation?: Array<number> Rotation matrix (3x3 matrix flattened in column major format (j*3+i indexing), this is equivalent to Fortran-order in numpy). This matrix will multiply the structure coordinates from the left. The default value is the identity matrix (corresponds to no rotation). Default: [1, 0, 0, 0, 1, 0, 0, 0, 1] translation?: [number, number, number] Translation vector, applied to the structure coordinates after rotation. The default value is the zero vector (corresponds to no translation). Default: [0, 0, 0]","title":"transform"},{"location":"tree-schema/#component","text":"This node instructs to create a component (i.e. a subset of the parent structure). Parent: structure Params: selector: (\"all\" | \"polymer\" | \"protein\" | \"nucleic\" | \"branched\" | \"ligand\" | \"ion\" | \"water\" | \"coarse\") | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> Defines what part of the parent structure should be included in this component.","title":"component"},{"location":"tree-schema/#component_from_uri","text":"This node instructs to create a component defined by an external annotation resource. Parent: structure Params: uri: string URL of the annotation resource. format: \"cif\" | \"bcif\" | \"json\" Format of the annotation resource. schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" and block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the component identifier. Default: \"component\" field_values?: Array<string> | null List of component identifiers (i.e. values in the field given by field_name ) which should be included in this component. If null , component identifiers are ignored (all annotation rows are included), and field_name field can be dropped from the annotation. Default: null","title":"component_from_uri"},{"location":"tree-schema/#component_from_source","text":"This node instructs to create a component defined by an annotation resource included in the same file this structure was loaded from. Only applicable if the structure was loaded from an mmCIF or BinaryCIF file. Parent: structure Params: schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from. If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from. If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the component identifier. Default: \"component\" field_values?: Array<string> | null List of component identifiers (i.e. values in the field given by field_name ) which should be included in this component. If null , component identifiers are ignored (all annotation rows are included), and field_name field can be dropped from the annotation. Default: null","title":"component_from_source"},{"location":"tree-schema/#representation","text":"This node instructs to create a visual representation of a component. Parent: component or component_from_uri or component_from_source Params: type: cartoon | ball_and_stick | spacefill | carbohydrate | surface Representation type [This parameter determines the rest of parameters] Case type: \"cartoon\" : size_factor?: number Scales the corresponding visuals. Default: 1 tubular_helices?: boolean Simplify corkscrew helices to tubes. Default: false Case type: \"ball_and_stick\" : size_factor?: number Scales the corresponding visuals. Default: 1 ignore_hydrogens?: boolean Controls whether hydrogen atoms are drawn. Default: false Case type: \"spacefill\" : size_factor?: number Scales the corresponding visuals. Default: 1 ignore_hydrogens?: boolean Controls whether hydrogen atoms are drawn. Default: false Case type: \"carbohydrate\" : size_factor?: number Scales the corresponding visuals. Default: 1 Case type: \"surface\" : size_factor?: number Scales the corresponding visuals. Default: 1 ignore_hydrogens?: boolean Controls whether hydrogen atoms are drawn. Default: false","title":"representation"},{"location":"tree-schema/#volume","text":"This node instructs to create a volume from a parsed data resource. \"Volume\" refers to an internal representation of volumetric data without any visual representation. Parent: parse Params: channel_id?: string | null Channel identifier (only applies when the input data contain multiple channels). Default: null","title":"volume"},{"location":"tree-schema/#volume_representation","text":"This node instructs to create a visual representation of a volume. Parent: volume Params: type: isosurface Representation type [This parameter determines the rest of parameters] Case type: \"isosurface\" : relative_isovalue?: number | null Relative isovalue. Default: null absolute_isovalue?: number | null Absolute isovalue. Overrides relative_isovalue . Default: null show_wireframe?: boolean Show mesh wireframe. Defaults to false. Default: false show_faces?: boolean Show mesh faces. Defaults to true. Default: true","title":"volume_representation"},{"location":"tree-schema/#color","text":"This node instructs to apply color to a visual representation. Parent: representation or volume_representation Params: color?: ColorName | HexColor Color to apply to the representation. Can be either an X11 color name (e.g. \"red\" ) or a hexadecimal code (e.g. \"#FF0011\" ). Default: \"white\" selector?: (\"all\" | \"polymer\" | \"protein\" | \"nucleic\" | \"branched\" | \"ligand\" | \"ion\" | \"water\" | \"coarse\") | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> Defines to what part of the representation this color should be applied. Default: \"all\"","title":"color"},{"location":"tree-schema/#color_from_uri","text":"This node instructs to apply colors to a visual representation. The colors are defined by an external annotation resource. Parent: representation Params: uri: string URL of the annotation resource. format: \"cif\" | \"bcif\" | \"json\" Format of the annotation resource. schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" and block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the color. Default: \"color\"","title":"color_from_uri"},{"location":"tree-schema/#color_from_source","text":"This node instructs to apply colors to a visual representation. The colors are defined by an annotation resource included in the same file this structure was loaded from. Only applicable if the structure was loaded from an mmCIF or BinaryCIF file. Parent: representation Params: schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from. If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from. If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the color. Default: \"color\"","title":"color_from_source"},{"location":"tree-schema/#opacity","text":"This node instructs to apply opacity/transparency to a visual representation. Parent: representation or volume_representation Params: opacity: number Opacity of a representation. 0.0: fully transparent, 1.0: fully opaque.","title":"opacity"},{"location":"tree-schema/#label","text":"This node instructs to add a label (textual visual representation) to a component. Parent: component or component_from_uri or component_from_source Params: text: string Content of the shown label.","title":"label"},{"location":"tree-schema/#label_from_uri","text":"This node instructs to add labels (textual visual representations) to parts of a structure. The labels are defined by an external annotation resource. Parent: structure Params: uri: string URL of the annotation resource. format: \"cif\" | \"bcif\" | \"json\" Format of the annotation resource. schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" and block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the label text. Default: \"label\"","title":"label_from_uri"},{"location":"tree-schema/#label_from_source","text":"This node instructs to add labels (textual visual representations) to parts of a structure. The labels are defined by an annotation resource included in the same file this structure was loaded from. Only applicable if the structure was loaded from an mmCIF or BinaryCIF file. Parent: structure Params: schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from. If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from. If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the label text. Default: \"label\"","title":"label_from_source"},{"location":"tree-schema/#tooltip","text":"This node instructs to add a tooltip to a component. \"Tooltip\" is a text which is not a part of the visualization but should be presented to the users when they interact with the component (typically, the tooltip will be shown somewhere on the screen when the user hovers over a visual representation of the component). Parent: component or component_from_uri or component_from_source Params: text: string Content of the shown tooltip.","title":"tooltip"},{"location":"tree-schema/#tooltip_from_uri","text":"This node instructs to add tooltips to parts of a structure. The tooltips are defined by an external annotation resource. Parent: structure Params: uri: string URL of the annotation resource. format: \"cif\" | \"bcif\" | \"json\" Format of the annotation resource. schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when format is \"cif\" or \"bcif\" and block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from (only applies when format is \"cif\" or \"bcif\" ). If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the tooltip text. Default: \"tooltip\"","title":"tooltip_from_uri"},{"location":"tree-schema/#tooltip_from_source","text":"This node instructs to add tooltips to parts of a structure. The tooltips are defined by an annotation resource included in the same file this structure was loaded from. Only applicable if the structure was loaded from an mmCIF or BinaryCIF file. Parent: structure Params: schema: \"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\" Annotation schema defines what fields in the annotation will be taken into account. block_header?: string | null Header of the CIF block to read annotation from. If null , block is selected based on block_index . Default: null block_index?: Integer 0-based index of the CIF block to read annotation from (only applies when block_header is null ). Default: 0 category_name?: string | null Name of the CIF category to read annotation from. If null , the first category in the block is used. Default: null field_name?: string Name of the column in CIF or field name (key) in JSON that contains the tooltip text. Default: \"tooltip\"","title":"tooltip_from_source"},{"location":"tree-schema/#focus","text":"This node instructs to set the camera focus to a component (zoom in). Parent: root or component or component_from_uri or component_from_source or primitives or primitives_from_uri or volume or volume_representation Params: direction?: [number, number, number] Vector describing the direction of the view (camera position -> focused target). Default: [0, 0, -1] up?: [number, number, number] Vector which will be aligned with the screen Y axis. Default: [0, 1, 0] radius?: number | null Radius of the focused sphere (overrides radius_factor and radius_extra ). Default: null radius_factor?: number Radius of the focused sphere relative to the radius of parent component (default: 1). Focused radius = component_radius * radius_factor + radius_extent. Default: 1 radius_extent?: number Addition to the radius of the focused sphere, if computed from the radius of parent component (default: 0). Focused radius = component_radius * radius_factor + radius_extent. Default: 0","title":"focus"},{"location":"tree-schema/#camera","text":"This node instructs to set the camera position and orientation. Parent: root Params: target: [number, number, number] Coordinates of the point in space at which the camera is pointing. position: [number, number, number] Coordinates of the camera. up?: [number, number, number] Vector which will be aligned with the screen Y axis. Default: [0, 1, 0]","title":"camera"},{"location":"tree-schema/#canvas","text":"This node sets canvas properties. Parent: root Params: background_color: ColorName | HexColor Color of the canvas background. Can be either an X11 color name (e.g. \"red\" ) or a hexadecimal code (e.g. \"#FF0011\" ).","title":"canvas"},{"location":"tree-schema/#primitives","text":"This node groups a list of geometrical primitives Parent: structure or root Params: color?: ColorName | HexColor Default color for primitives in this group. Default: \"white\" label_color?: ColorName | HexColor Default label color for primitives in this group. Default: \"white\" tooltip?: string | null Default tooltip for primitives in this group. Default: null opacity?: number Opacity of primitive geometry in this group. Default: 1 label_opacity?: number Opacity of primitive labels in this group. Default: 1 instances?: Array<Array<number>> | null Instances of this primitive group defined as 4x4 column major (j * 4 + i indexing) transformation matrices. Default: null","title":"primitives"},{"location":"tree-schema/#primitives_from_uri","text":"This node loads a list of primitives from URI Parent: structure or root Params: uri: string Location of the resource. format: \"mvs-node-json\" Format of the data. references?: Array<string> List of nodes the data are referencing. Default: []","title":"primitives_from_uri"},{"location":"tree-schema/#primitive","text":"This node represents a geometrical primitive Parent: primitives Params: kind: mesh | lines | tube | arrow | distance_measurement | angle_measurement | label | ellipse | ellipsoid | box Kind of geometrical primitive [This parameter determines the rest of parameters] Case kind: \"mesh\" : vertices: Array<number> 3*n_vertices length array of floats with vertex position (x1, y1, z1, ...). indices: Array<Integer> 3*n_triangles length array of indices into vertices that form triangles (t1_1, t1_2, t1_3, ...). triangle_groups?: Array<Integer> | null Assign a number to each triangle to group them. If not specified, each triangle is considered a separate group (triangle i = group i). Default: null group_colors?: { [K in Integer]: (ColorName | HexColor) } Assign a color to each group. Where not assigned, uses color . Default: {} group_tooltips?: { [K in Integer]: string } Assign a tooltip to each group. Where not assigned, uses tooltip . Default: {} color?: (ColorName | HexColor) | null Color of the triangles and wireframe. Can be overwritten by group_colors . If not specified, uses the parent primitives group color . Default: null tooltip?: string | null Tooltip shown when hovering over the mesh. Can be overwritten by group_tooltips . If not specified, uses the parent primitives group tooltip . Default: null show_triangles?: boolean Determine whether to render triangles of the mesh. Default: true show_wireframe?: boolean Determine whether to render wireframe of the mesh. Default: false wireframe_width?: number Wireframe line width (in screen-space units). Default: 1 wireframe_color?: (ColorName | HexColor) | null Wireframe color. If not specified, uses group_colors . Default: null Case kind: \"lines\" : vertices: Array<number> 3*n_vertices length array of floats with vertex position (x1, y1, z1, ...). indices: Array<Integer> 2*n_lines length array of indices into vertices that form lines (l1_1, l1_2, ...). line_groups?: Array<Integer> | null Assign a number to each triangle to group them. If not specified, each line is considered a separate group (line i = group i). Default: null group_colors?: { [K in Integer]: (ColorName | HexColor) } Assign a color to each group. Where not assigned, uses color . Default: {} group_tooltips?: { [K in Integer]: string } Assign a tooltip to each group. Where not assigned, uses tooltip . Default: {} group_widths?: { [K in Integer]: number } Assign a line width to each group. Where not assigned, uses width . Default: {} color?: (ColorName | HexColor) | null Color of the lines. Can be overwritten by group_colors . If not specified, uses the parent primitives group color . Default: null tooltip?: string | null Tooltip shown when hovering over the lines. Can be overwritten by group_tooltips . If not specified, uses the parent primitives group tooltip . Default: null width?: number Line width (in screen-space units). Can be overwritten by group_widths . Default: 1 Case kind: \"tube\" : start: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Start point of the tube. end: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> End point of the tube. radius?: number Tube radius (in Angstroms). Default: 0.05 dash_length?: number | null Length of each dash and gap between dashes. If not specified (null), draw full line. Default: null color?: (ColorName | HexColor) | null Color of the tube. If not specified, uses the parent primitives group color . Default: null tooltip?: string | null Tooltip to show when hovering over the tube. If not specified, uses the parent primitives group tooltip . Default: null Case kind: \"arrow\" : start: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Start point of the arrow. end?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null End point of the arrow. Default: null direction?: [number, number, number] | null If specified, the endpoint is computed as start + direction. Default: null length?: number | null Length of the arrow. If unset, the distance between start and end is used. Default: null show_start_cap?: boolean Draw a cap at the start of the arrow. Default: false start_cap_length?: number Length of the start cap. Default: 0.1 start_cap_radius?: number Radius of the start cap. Default: 0.1 show_end_cap?: boolean Draw a cap at the end of the arrow. Default: false end_cap_length?: number Length of the end cap. Default: 0.1 end_cap_radius?: number Radius of the end cap. Default: 0.1 show_tube?: boolean Draw a tube connecting the start and end points. Default: true tube_radius?: number Tube radius (in Angstroms). Default: 0.05 tube_dash_length?: number | null Length of each dash and gap between dashes. If not specified (null), draw full line. Default: null color?: (ColorName | HexColor) | null Color of the tube. If not specified, uses the parent primitives group color . Default: null tooltip?: string | null Tooltip to show when hovering over the arrow. If not specified, uses the parent primitives group tooltip . Default: null Case kind: \"distance_measurement\" : start: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Start point of the tube. end: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> End point of the tube. radius?: number Tube radius (in Angstroms). Default: 0.05 dash_length?: number | null Length of each dash and gap between dashes. If not specified (null), draw full line. Default: null color?: (ColorName | HexColor) | null Color of the tube. If not specified, uses the parent primitives group color . Default: null label_template?: string Template used to construct the label. Use {{distance}} as placeholder for the distance. Default: \"{{distance}}\" label_size?: number | null Size of the label (text height in Angstroms). If not specified, size will be relative to the distance (see label_auto_size_scale, label_auto_size_min). Default: null label_auto_size_scale?: number Scaling factor for relative size. Default: 0.1 label_auto_size_min?: number Minimum size for relative size. Default: 0 label_color?: (ColorName | HexColor) | null Color of the label. If not specified, uses the parent primitives group label_color . Default: null Case kind: \"angle_measurement\" : a: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Point A. b: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Point B. c: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Point C. label_template?: string Template used to construct the label. Use {{angle}} as placeholder for the angle in radians. Default: \"{{angle}}\" label_size?: number | null Size of the label (text height in Angstroms). If not specified, size will be relative to the distance (see label_auto_size_scale, label_auto_size_min). Default: null label_auto_size_scale?: number Scaling factor for relative size. Default: 0.33 label_auto_size_min?: number Minimum size for relative size. Default: 0 label_color?: (ColorName | HexColor) | null Color of the label. If not specified, uses the parent primitives group label_color . Default: null show_vector?: boolean Draw vectors between (a, b) and (b, c). Default: true vector_color?: (ColorName | HexColor) | null Color of the vectors. Default: null show_section?: boolean Draw a filled circle section representing the angle. Default: true section_color?: (ColorName | HexColor) | null Color of the angle section. If not specified, the primitives group color is used. Default: null section_radius?: number | null Radius of the angle section. In angstroms. Default: null section_radius_scale?: number Factor to scale the radius of the angle section. Ignored if section_radius is set. Default: 0.33 Case kind: \"label\" : position: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> Position of this label. text: string The label. label_size?: number Size of the label (text height in Angstroms). Default: 1 label_color?: (ColorName | HexColor) | null Color of the label. If not specified, uses the parent primitives group label_color . Default: null label_offset?: number Camera-facing offset to prevent overlap with geometry. Default: 0 Case kind: \"ellipse\" : color?: (ColorName | HexColor) | null Color of the ellipse. If not specified, uses the parent primitives group color . Default: null as_circle?: boolean If true, ignores radius_minor/magnitude of the minor axis. Default: false center: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> The center of the ellipse. major_axis?: [number, number, number] | null Major axis of this ellipse. Default: null minor_axis?: [number, number, number] | null Minor axis of this ellipse. Default: null major_axis_endpoint?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null Major axis endpoint. If specified, overrides major axis to be major_axis_endpoint - center. Default: null minor_axis_endpoint?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null Minor axis endpoint. If specified, overrides minor axis to be minor_axis_endpoint - center. Default: null radius_major?: number | null Radius of the major axis. If unset, the length of the major axis is used. Default: null radius_minor?: number | null Radius of the minor axis. If unset, the length of the minor axis is used. Default: null theta_start?: number Start of the arc. In radians Default: 0 theta_end?: number End of the arc. In radians Default: 6.283185307179586 tooltip?: string | null Tooltip to show when hovering over the tube. If not specified, uses the parent primitives group tooltip . Default: null Case kind: \"ellipsoid\" : color?: (ColorName | HexColor) | null Color of the ellipsoid. If not specified, uses the parent primitives group color . Default: null center: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> The center of the ellipsoid. major_axis?: [number, number, number] | null Major axis of this ellipsoid. Default: null minor_axis?: [number, number, number] | null Minor axis of this ellipsoid. Default: null major_axis_endpoint?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null Major axis endpoint. If specified, overrides major axis to be major_axis_endpoint - center. Default: null minor_axis_endpoint?: ([number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>>) | null Minor axis endpoint. If specified, overrides minor axis to be minor_axis_endpoint - center. Default: null radius?: ([number, number, number] | number) | null Radii of the ellipsoid along each axis. Default: null radius_extent?: ([number, number, number] | number) | null Added to the radii of the ellipsoid along each axis. Default: null tooltip?: string | null Tooltip to show when hovering over the tube. If not specified, uses the parent primitives group tooltip . Default: null Case kind: \"box\" : center: [number, number, number] | Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }> | Array<Partial<{ structure_ref: string, expression_schema: (\"whole_structure\" | \"entity\" | \"chain\" | \"auth_chain\" | \"residue\" | \"auth_residue\" | \"residue_range\" | \"auth_residue_range\" | \"atom\" | \"auth_atom\" | \"all_atomic\"), expressions: Array<Partial<{ label_entity_id: string, label_asym_id: string, auth_asym_id: string, label_seq_id: Integer, auth_seq_id: Integer, pdbx_PDB_ins_code: string, beg_label_seq_id: Integer, end_label_seq_id: Integer, beg_auth_seq_id: Integer, end_auth_seq_id: Integer, label_atom_id: string, auth_atom_id: string, type_symbol: string, atom_id: Integer, atom_index: Integer }>> }>> The center of the box. extent?: [number, number, number] | null The width, the height, and the depth of the box. Added to the bounding box determined by the center. Default: null show_faces?: boolean Determine whether to render the faces of the box. Default: true face_color?: (ColorName | HexColor) | null Color of the box faces. Default: null show_edges?: boolean Determine whether to render the edges of the box. Default: false edge_radius?: number Radius of the box edges. In angstroms. Default: 0.1 edge_color?: (ColorName | HexColor) | null Color of the edges. Default: null tooltip?: string | null Tooltip to show when hovering over the tube. If not specified, uses the parent primitives group tooltip . Default: null","title":"primitive"},{"location":"volumes/","text":"MolViewSpec volumes Electron density data from MX and EM experiments is invaluable when interrogating molecular structures. MolViewSpec allows you to add density data to a scene by parsing a dedicated file or by querying the Mol* Volume Server (PDBe: https://www.ebi.ac.uk/pdbe/densities/ - RCSB PDB: https://maps.rcsb.org/) for this data when working with PDB entries. Parsing a file Volumetric data has a similar flow as the loading of standard molecular mmCIF data: download , parse , and volume (comparable to model_structure or assembly_structure ). Specify the format as part of the parse step. builder = create_builder () download = builder . download ( url = \"https://www.ebi.ac.uk/pdbe/entry-files/1tqn.ccp4\" ) volume = download . parse ( format = \"map\" ) . volume () Analogous to standard molecular data, dedicated and customizable representations can now be added. In this case isosurface . relative_isovalue or absolute_isovalue adjust, which parts of the data are shown. show_wireframe and show_faces provide options for finer-grained customization. Define colors and transparency as usual. ( volume . representation ( type = \"isosurface\" , relative_isovalue = 1 , show_wireframe = True ) . color ( color = \"blue\" ) . opacity ( opacity = 0.66 ) ) Querying Mol* Volume Server Density data is particularly useful when combined with 3D structure data. Create a view of 1tqn, which represents the ligand as ball-and-stick and focuses on it. builder = create_builder () structure = builder . download ( url = _url_for_mmcif ( \"1tqn\" )) . parse ( format = \"mmcif\" ) . model_structure () structure . component ( selector = \"polymer\" ) . representation ( type = \"cartoon\" ) . color ( color = \"white\" ) ligand = structure . component ( selector = \"ligand\" ) ligand . representation ( type = \"ball_and_stick\" ) . color ( custom = { \"molstar_color_theme_name\" : \"element-symbol\" }) ligand . focus ( up = [ 0.98 , - 0.19 , 0 ], direction = [ - 28.47 , - 17.66 , - 16.32 ], radius = 14 , radius_extent = 5 ) Enrich this view with density data, provided by PDBe's Volume Server . volume_data = builder . download ( url = \"https://www.ebi.ac.uk/pdbe/densities/x-ray/1tqn/box/-22.367,-33.367,-21.634/-7.106,-10.042,-0.937?detail=3\" ) . parse ( format = \"bcif\" ) With this data at hand, dedicated channels can be created that visualize the electron density. volume_data . volume ( channel_id = \"2FO-FC\" ) . representation ( type = \"isosurface\" , relative_isovalue = 1.5 , show_wireframe = True , show_faces = False , ) . color ( color = \"blue\" ) . opacity ( opacity = 0.3 ) fo_fc = volume_data . volume ( channel_id = \"FO-FC\" ) fo_fc . representation ( type = \"isosurface\" , relative_isovalue = 3 , show_wireframe = True ) . color ( color = \"green\" ) . opacity ( opacity = 0.3 ) fo_fc . representation ( type = \"isosurface\" , relative_isovalue =- 3 , show_wireframe = True ) . color ( color = \"red\" ) . opacity ( opacity = 0.3 )","title":"Volumetric Data"},{"location":"volumes/#molviewspec-volumes","text":"Electron density data from MX and EM experiments is invaluable when interrogating molecular structures. MolViewSpec allows you to add density data to a scene by parsing a dedicated file or by querying the Mol* Volume Server (PDBe: https://www.ebi.ac.uk/pdbe/densities/ - RCSB PDB: https://maps.rcsb.org/) for this data when working with PDB entries.","title":"MolViewSpec volumes"},{"location":"volumes/#parsing-a-file","text":"Volumetric data has a similar flow as the loading of standard molecular mmCIF data: download , parse , and volume (comparable to model_structure or assembly_structure ). Specify the format as part of the parse step. builder = create_builder () download = builder . download ( url = \"https://www.ebi.ac.uk/pdbe/entry-files/1tqn.ccp4\" ) volume = download . parse ( format = \"map\" ) . volume () Analogous to standard molecular data, dedicated and customizable representations can now be added. In this case isosurface . relative_isovalue or absolute_isovalue adjust, which parts of the data are shown. show_wireframe and show_faces provide options for finer-grained customization. Define colors and transparency as usual. ( volume . representation ( type = \"isosurface\" , relative_isovalue = 1 , show_wireframe = True ) . color ( color = \"blue\" ) . opacity ( opacity = 0.66 ) )","title":"Parsing a file"},{"location":"volumes/#querying-mol-volume-server","text":"Density data is particularly useful when combined with 3D structure data. Create a view of 1tqn, which represents the ligand as ball-and-stick and focuses on it. builder = create_builder () structure = builder . download ( url = _url_for_mmcif ( \"1tqn\" )) . parse ( format = \"mmcif\" ) . model_structure () structure . component ( selector = \"polymer\" ) . representation ( type = \"cartoon\" ) . color ( color = \"white\" ) ligand = structure . component ( selector = \"ligand\" ) ligand . representation ( type = \"ball_and_stick\" ) . color ( custom = { \"molstar_color_theme_name\" : \"element-symbol\" }) ligand . focus ( up = [ 0.98 , - 0.19 , 0 ], direction = [ - 28.47 , - 17.66 , - 16.32 ], radius = 14 , radius_extent = 5 ) Enrich this view with density data, provided by PDBe's Volume Server . volume_data = builder . download ( url = \"https://www.ebi.ac.uk/pdbe/densities/x-ray/1tqn/box/-22.367,-33.367,-21.634/-7.106,-10.042,-0.937?detail=3\" ) . parse ( format = \"bcif\" ) With this data at hand, dedicated channels can be created that visualize the electron density. volume_data . volume ( channel_id = \"2FO-FC\" ) . representation ( type = \"isosurface\" , relative_isovalue = 1.5 , show_wireframe = True , show_faces = False , ) . color ( color = \"blue\" ) . opacity ( opacity = 0.3 ) fo_fc = volume_data . volume ( channel_id = \"FO-FC\" ) fo_fc . representation ( type = \"isosurface\" , relative_isovalue = 3 , show_wireframe = True ) . color ( color = \"green\" ) . opacity ( opacity = 0.3 ) fo_fc . representation ( type = \"isosurface\" , relative_isovalue =- 3 , show_wireframe = True ) . color ( color = \"red\" ) . opacity ( opacity = 0.3 )","title":"Querying Mol* Volume Server"},{"location":"mvs-molstar-extension/","text":"Mol* MVS Extension Mol* MolViewSpec extension provides functionality for building, validating, and visualizing MVS views. Graphical user interface There are multiple ways to load MolViewSpec views ( .mvsj / .mvsx ) into Mol* Viewer: Drag&drop support: The easiest way to load a MVS view into Mol* Viewer is to drag a .mvsj or .mvsx file and drop it in a browser window with Mol* Viewer. Test with these files: 1cbs.mvsj , 1h9t.mvsx Load via menu: Another way to load a MVS view is to use \"Download File\" or \"Open Files\" action, available in the \"Home\" tab in the left panel. For these actions, the \"Format\" parameter must be set to \"MVSJ\" or \"MVSX\" (in the \"Miscellaneous\" category) or \"Auto\". Test with this URL: https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs.mvsj URL parameters: Mol* Viewer supports mvs-url , mvs-data , and mvs-format URL parameters to specify a MVS view to be loaded when the viewer is initialized. mvs-url specifies the address from which the MVS view should be retrieved. mvs-data specifies the MVS view data directly. Keep in mind that some characters must be escaped to be used in the URL. Also beware that URLs longer than 2000 character may not work in all browsers. Because of these limitations, the preferred method it to host the data somewhere and use mvs-url instead. mvs-format specifies the format of the MVS view data from mvs-url or mvs-data . Allowed values are mvsj and mvsx (default is mvsj ). Examples of URL parameter usage: Load MVSJ Load MVSX URL Encoded MVSJ URL Encoded MVSX Programming interface Most functions for manipulation of MVS data (including parsing, encoding, validating, and building) are provided by the MVSData object (defined in src/extensions/mvs/mvs-data.ts ). In TypeScript, MVSData is also the type for a MVS view. The loadMVS function (defined in src/extensions/mvs/load.ts ) can be used to load MVS view data into Mol* Viewer. Example usage: // Fetch a MVS, validate, and load const response = await fetch ( 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs.mvsj' ); const rawData = await response . text (); const mvsData : MVSData = MVSData . fromMVSJ ( rawData ); if ( ! MVSData . isValid ( mvsData )) throw new Error ( `Oh no: ${ MVSData . validationIssues ( mvsData ) } ` ); await loadMVS ( this . plugin , mvsData , { replaceExisting : true }); console . log ( 'Loaded this:' , MVSData . toPrettyString ( mvsData )); console . log ( 'Loaded this:' , MVSData . toMVSJ ( mvsData )); // Build a MVS and load const builder = MVSData . createBuilder (); const structure = builder . download ({ url : 'https://www.ebi.ac.uk/pdbe/entry-files/download/1og2_updated.cif' }). parse ({ format : 'mmcif' }). modelStructure (); structure . component ({ selector : 'polymer' }). representation ({ type : 'cartoon' }); structure . component ({ selector : 'ligand' }). representation ({ type : 'ball_and_stick' }). color ({ color : '#aa55ff' }); const mvsData2 : MVSData = builder . getState (); await loadMVS ( this . plugin , mvsData2 , { replaceExisting : false }); When using the pre-built Mol* plugin bundle, MVSData and loadMVS are exposed as molstar.PluginExtensions.mvs.MVSData and molstar.PluginExtensions.mvs.loadMVS . Furthermore, the molstar.Viewer class has loadMvsFromUrl and loadMvsData methods, providing the same functionality as mvs-url and mvs-data URL parameters. See MolViewSpec extension in Mol* - Integration in web pages for a demonstration. Command-line utilities The MVS extension in Mol* provides a few command-line utilities, which can be executed via NodeJS: mvs-validate provides validation of MolViewSpec files mvs-render creates images based on MolViewSpec files mvs-print-schema prints MolViewSpec tree schema (i.e. currently supported node types and their parameters) Example usage: # Clone Mol* repo, install, and build git clone https://github.com/molstar/molstar.git cd molstar/ npm install && npm run build # Validate a MolViewSpec file `examples/mvs/1cbs.mvsj` node lib/commonjs/cli/mvs/mvs-validate.js examples/mvs/1cbs.mvsj # Render a MolViewSpec file `examples/mvs/1cbs.mvsj` to `../outputs/1cbs.png` node lib/commonjs/cli/mvs/mvs-render.js -i examples/mvs/1cbs.mvsj -o ../outputs/1cbs.png --size 800x600 --molj # Print MolViewSpec tree schema formatted as markdown node lib/commonjs/cli/mvs/mvs-print-schema.js --markdown (An alternative to cloning the GitHub repository is to install Mol* package from npm by npm install molstar canvas gl jpeg-js pngjs . Then you can type npx mvs-validate ... instead of node lib/commonjs/cli/mvs/mvs-validate.js ... )","title":"Overview"},{"location":"mvs-molstar-extension/#mol-mvs-extension","text":"Mol* MolViewSpec extension provides functionality for building, validating, and visualizing MVS views.","title":"Mol* MVS Extension"},{"location":"mvs-molstar-extension/#graphical-user-interface","text":"There are multiple ways to load MolViewSpec views ( .mvsj / .mvsx ) into Mol* Viewer: Drag&drop support: The easiest way to load a MVS view into Mol* Viewer is to drag a .mvsj or .mvsx file and drop it in a browser window with Mol* Viewer. Test with these files: 1cbs.mvsj , 1h9t.mvsx Load via menu: Another way to load a MVS view is to use \"Download File\" or \"Open Files\" action, available in the \"Home\" tab in the left panel. For these actions, the \"Format\" parameter must be set to \"MVSJ\" or \"MVSX\" (in the \"Miscellaneous\" category) or \"Auto\". Test with this URL: https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs.mvsj URL parameters: Mol* Viewer supports mvs-url , mvs-data , and mvs-format URL parameters to specify a MVS view to be loaded when the viewer is initialized. mvs-url specifies the address from which the MVS view should be retrieved. mvs-data specifies the MVS view data directly. Keep in mind that some characters must be escaped to be used in the URL. Also beware that URLs longer than 2000 character may not work in all browsers. Because of these limitations, the preferred method it to host the data somewhere and use mvs-url instead. mvs-format specifies the format of the MVS view data from mvs-url or mvs-data . Allowed values are mvsj and mvsx (default is mvsj ). Examples of URL parameter usage: Load MVSJ Load MVSX URL Encoded MVSJ URL Encoded MVSX","title":"Graphical user interface"},{"location":"mvs-molstar-extension/#programming-interface","text":"Most functions for manipulation of MVS data (including parsing, encoding, validating, and building) are provided by the MVSData object (defined in src/extensions/mvs/mvs-data.ts ). In TypeScript, MVSData is also the type for a MVS view. The loadMVS function (defined in src/extensions/mvs/load.ts ) can be used to load MVS view data into Mol* Viewer. Example usage: // Fetch a MVS, validate, and load const response = await fetch ( 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs.mvsj' ); const rawData = await response . text (); const mvsData : MVSData = MVSData . fromMVSJ ( rawData ); if ( ! MVSData . isValid ( mvsData )) throw new Error ( `Oh no: ${ MVSData . validationIssues ( mvsData ) } ` ); await loadMVS ( this . plugin , mvsData , { replaceExisting : true }); console . log ( 'Loaded this:' , MVSData . toPrettyString ( mvsData )); console . log ( 'Loaded this:' , MVSData . toMVSJ ( mvsData )); // Build a MVS and load const builder = MVSData . createBuilder (); const structure = builder . download ({ url : 'https://www.ebi.ac.uk/pdbe/entry-files/download/1og2_updated.cif' }). parse ({ format : 'mmcif' }). modelStructure (); structure . component ({ selector : 'polymer' }). representation ({ type : 'cartoon' }); structure . component ({ selector : 'ligand' }). representation ({ type : 'ball_and_stick' }). color ({ color : '#aa55ff' }); const mvsData2 : MVSData = builder . getState (); await loadMVS ( this . plugin , mvsData2 , { replaceExisting : false }); When using the pre-built Mol* plugin bundle, MVSData and loadMVS are exposed as molstar.PluginExtensions.mvs.MVSData and molstar.PluginExtensions.mvs.loadMVS . Furthermore, the molstar.Viewer class has loadMvsFromUrl and loadMvsData methods, providing the same functionality as mvs-url and mvs-data URL parameters. See MolViewSpec extension in Mol* - Integration in web pages for a demonstration.","title":"Programming interface"},{"location":"mvs-molstar-extension/#command-line-utilities","text":"The MVS extension in Mol* provides a few command-line utilities, which can be executed via NodeJS: mvs-validate provides validation of MolViewSpec files mvs-render creates images based on MolViewSpec files mvs-print-schema prints MolViewSpec tree schema (i.e. currently supported node types and their parameters) Example usage: # Clone Mol* repo, install, and build git clone https://github.com/molstar/molstar.git cd molstar/ npm install && npm run build # Validate a MolViewSpec file `examples/mvs/1cbs.mvsj` node lib/commonjs/cli/mvs/mvs-validate.js examples/mvs/1cbs.mvsj # Render a MolViewSpec file `examples/mvs/1cbs.mvsj` to `../outputs/1cbs.png` node lib/commonjs/cli/mvs/mvs-render.js -i examples/mvs/1cbs.mvsj -o ../outputs/1cbs.png --size 800x600 --molj # Print MolViewSpec tree schema formatted as markdown node lib/commonjs/cli/mvs/mvs-print-schema.js --markdown (An alternative to cloning the GitHub repository is to install Mol* package from npm by npm install molstar canvas gl jpeg-js pngjs . Then you can type npx mvs-validate ... instead of node lib/commonjs/cli/mvs/mvs-validate.js ... )","title":"Command-line utilities"},{"location":"mvs-molstar-extension/integration/","text":"Mol* MVS Extension: Integration in web pages This page demonstrates several methods to integrate Mol* Viewer in a web page and use MolViewSpec functionality. .button { padding: 5px; background: gainsboro; cursor: pointer; } Example 1 Get MVS view from a server and pass to the viewer The recommended method is to serve the MVS files from your server (either as static files or generated by the server on-demand) and call the loadMvsFromUrl method to retrieve and load them. This example uses a MVS file from the address specified in the sourceUrl variable. If the MVS view file contains relative references, they will be resolved as relative to sourceUrl . <!DOCTYPE html> < html lang = \"en\" > < head > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < script src = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.js\" ></ script > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < link rel = \"stylesheet\" type = \"text/css\" href = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.css\" /> </ head > < body > < div id = \"viewer1\" style = \"position: relative; width: 500px; height: 500px;\" ></ div > < script > const sourceUrl = 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1h9t_domain_labels.mvsj' ; molstar . Viewer . create ( 'viewer1' , { layoutIsExpanded : false , layoutShowControls : false }) . then ( viewer => viewer . loadMvsFromUrl ( sourceUrl , 'mvsj' )); </ script > </ body > </ html > Result: const sourceUrl = 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1h9t_domain_labels.mvsj'; molstar.Viewer.create('viewer1', { layoutIsExpanded: false, layoutShowControls: false }).then(viewer => viewer.loadMvsFromUrl(sourceUrl, 'mvsj')); Example 2 Replace MVS view after loading A variation of the first example is to molstar.PluginExtensions.mvs.loadMVS instead of loadMvsFromUrl . This allows replacing the MVS view after it has been loaded. <!DOCTYPE html> < html lang = \"en\" > < head > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < script src = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.js\" ></ script > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < link rel = \"stylesheet\" type = \"text/css\" href = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.css\" /> </ head > < body > < div id = \"viewer2\" style = \"position: relative; width: 500px; height: 500px;\" ></ div > < button class = \"button\" onclick = \"loadView1();\" > View 1 </ button > < button class = \"button\" onclick = \"loadView2();\" > View 2 </ button > < script > let theViewer ; function load ( viewer , url , replace ) { fetch ( url ) . then ( response => response . text ()) . then ( text => molstar . PluginExtensions . mvs . MVSData . fromMVSJ ( text )) . then ( mvsData => molstar . PluginExtensions . mvs . loadMVS ( viewer . plugin , mvsData , { sourceUrl : url , sanityChecks : true , replaceExisting : replace })); } function loadView1 () { load ( theViewer , 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs.mvsj' , true ); } function loadView2 () { load ( theViewer , 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs-focus.mvsj' , true ); } molstar . Viewer . create ( 'viewer2' , { layoutIsExpanded : false , layoutShowControls : false }) . then ( viewer => { theViewer = viewer ; loadView1 (); }); </ script > </ body > </ html > Result: View 1 View 2 let theViewer; function load(viewer, url, replace) { fetch(url) .then(response => response.text()) .then(text => molstar.PluginExtensions.mvs.MVSData.fromMVSJ(text)) .then(mvsData => molstar.PluginExtensions.mvs.loadMVS(viewer.plugin, mvsData, { sourceUrl: url, sanityChecks: true, replaceExisting: replace })); } function loadView1() { load(theViewer, 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs.mvsj', true); } function loadView2() { load(theViewer, 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs-focus.mvsj', true); } molstar.Viewer.create('viewer2', { layoutIsExpanded: false, layoutShowControls: false }) .then(viewer => { theViewer = viewer; loadView1(); }); Example 3 Construct MVS view on frontend and pass to the viewer Another option is to utilize the MVS builder provided by the extension to build the view on frontend and then pass it to the viewer. This example builds the view in plain JavaScript, directly in a <script> tag in HTML. However, for a better developer experience consider writing the code in TypeScript. If the built MVS view contains relative references, they will be resolved as relative to the URL of this HTML page. <!DOCTYPE html> < html lang = \"en\" > < head > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < script src = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.js\" ></ script > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < link rel = \"stylesheet\" type = \"text/css\" href = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.css\" /> </ head > < body > < div id = \"viewer3\" style = \"position: relative; width: 500px; height: 500px;\" ></ div > < script > // Build an ad-hoc MVS view const builder = molstar . PluginExtensions . mvs . MVSData . createBuilder (); const structure = builder . download ({ url : 'https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif' }) . parse ({ format : 'bcif' }) . modelStructure ({}); structure . component ({ selector : 'polymer' }) . representation ({ type : 'cartoon' }) . color ({ color : 'green' }); structure . component ({ selector : 'ligand' }) . label ({ text : 'Retinoic acid' }) . focus ({}) . representation ({ type : 'ball_and_stick' }) . color ({ color : '#cc3399' }); const mvsData = builder . getState (); // Initialize viewer and load MVSJ molstar . Viewer . create ( 'viewer3' , { layoutIsExpanded : false , layoutShowControls : false }) . then ( viewer => molstar . PluginExtensions . mvs . loadMVS ( viewer . plugin , mvsData , { sourceUrl : undefined , sanityChecks : true , replaceExisting : false })); </ script > </ body > </ html > Result: // Build an ad-hoc MVS view const builder = molstar.PluginExtensions.mvs.MVSData.createBuilder(); const structure = builder .download({ url: 'https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif' }) .parse({ format: 'bcif' }) .modelStructure({}); structure .component({ selector: 'polymer' }) .representation({ type: 'cartoon' }) .color({ color: 'green' }); structure .component({ selector: 'ligand' }) .label({ text: 'Retinoic acid' }) .focus({}) .representation({ type: 'ball_and_stick' }) .color({ color: '#cc3399' }); const mvsData = builder.getState(); // Initialize viewer and load MVSJ molstar.Viewer .create('viewer3', { layoutIsExpanded: false, layoutShowControls: false }) .then(viewer => molstar.PluginExtensions.mvs.loadMVS(viewer.plugin, mvsData, { sourceUrl: undefined, sanityChecks: true, replaceExisting: false }));","title":"Integration Examples"},{"location":"mvs-molstar-extension/integration/#mol-mvs-extension-integration-in-web-pages","text":"This page demonstrates several methods to integrate Mol* Viewer in a web page and use MolViewSpec functionality. .button { padding: 5px; background: gainsboro; cursor: pointer; }","title":"Mol* MVS Extension: Integration in web pages"},{"location":"mvs-molstar-extension/integration/#example-1","text":"","title":"Example 1"},{"location":"mvs-molstar-extension/integration/#get-mvs-view-from-a-server-and-pass-to-the-viewer","text":"The recommended method is to serve the MVS files from your server (either as static files or generated by the server on-demand) and call the loadMvsFromUrl method to retrieve and load them. This example uses a MVS file from the address specified in the sourceUrl variable. If the MVS view file contains relative references, they will be resolved as relative to sourceUrl . <!DOCTYPE html> < html lang = \"en\" > < head > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < script src = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.js\" ></ script > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < link rel = \"stylesheet\" type = \"text/css\" href = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.css\" /> </ head > < body > < div id = \"viewer1\" style = \"position: relative; width: 500px; height: 500px;\" ></ div > < script > const sourceUrl = 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1h9t_domain_labels.mvsj' ; molstar . Viewer . create ( 'viewer1' , { layoutIsExpanded : false , layoutShowControls : false }) . then ( viewer => viewer . loadMvsFromUrl ( sourceUrl , 'mvsj' )); </ script > </ body > </ html > Result: const sourceUrl = 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1h9t_domain_labels.mvsj'; molstar.Viewer.create('viewer1', { layoutIsExpanded: false, layoutShowControls: false }).then(viewer => viewer.loadMvsFromUrl(sourceUrl, 'mvsj'));","title":"Get MVS view from a server and pass to the viewer"},{"location":"mvs-molstar-extension/integration/#example-2","text":"","title":"Example 2"},{"location":"mvs-molstar-extension/integration/#replace-mvs-view-after-loading","text":"A variation of the first example is to molstar.PluginExtensions.mvs.loadMVS instead of loadMvsFromUrl . This allows replacing the MVS view after it has been loaded. <!DOCTYPE html> < html lang = \"en\" > < head > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < script src = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.js\" ></ script > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < link rel = \"stylesheet\" type = \"text/css\" href = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.css\" /> </ head > < body > < div id = \"viewer2\" style = \"position: relative; width: 500px; height: 500px;\" ></ div > < button class = \"button\" onclick = \"loadView1();\" > View 1 </ button > < button class = \"button\" onclick = \"loadView2();\" > View 2 </ button > < script > let theViewer ; function load ( viewer , url , replace ) { fetch ( url ) . then ( response => response . text ()) . then ( text => molstar . PluginExtensions . mvs . MVSData . fromMVSJ ( text )) . then ( mvsData => molstar . PluginExtensions . mvs . loadMVS ( viewer . plugin , mvsData , { sourceUrl : url , sanityChecks : true , replaceExisting : replace })); } function loadView1 () { load ( theViewer , 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs.mvsj' , true ); } function loadView2 () { load ( theViewer , 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs-focus.mvsj' , true ); } molstar . Viewer . create ( 'viewer2' , { layoutIsExpanded : false , layoutShowControls : false }) . then ( viewer => { theViewer = viewer ; loadView1 (); }); </ script > </ body > </ html > Result: View 1 View 2 let theViewer; function load(viewer, url, replace) { fetch(url) .then(response => response.text()) .then(text => molstar.PluginExtensions.mvs.MVSData.fromMVSJ(text)) .then(mvsData => molstar.PluginExtensions.mvs.loadMVS(viewer.plugin, mvsData, { sourceUrl: url, sanityChecks: true, replaceExisting: replace })); } function loadView1() { load(theViewer, 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs.mvsj', true); } function loadView2() { load(theViewer, 'https://raw.githubusercontent.com/molstar/molstar/master/examples/mvs/1cbs-focus.mvsj', true); } molstar.Viewer.create('viewer2', { layoutIsExpanded: false, layoutShowControls: false }) .then(viewer => { theViewer = viewer; loadView1(); });","title":"Replace MVS view after loading"},{"location":"mvs-molstar-extension/integration/#example-3","text":"","title":"Example 3"},{"location":"mvs-molstar-extension/integration/#construct-mvs-view-on-frontend-and-pass-to-the-viewer","text":"Another option is to utilize the MVS builder provided by the extension to build the view on frontend and then pass it to the viewer. This example builds the view in plain JavaScript, directly in a <script> tag in HTML. However, for a better developer experience consider writing the code in TypeScript. If the built MVS view contains relative references, they will be resolved as relative to the URL of this HTML page. <!DOCTYPE html> < html lang = \"en\" > < head > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < script src = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.js\" ></ script > <!-- Replace \"latest\" by the specific version you want to use, e.g. \"4.0.0\" --> < link rel = \"stylesheet\" type = \"text/css\" href = \"https://cdn.jsdelivr.net/npm/molstar@latest/build/viewer/molstar.css\" /> </ head > < body > < div id = \"viewer3\" style = \"position: relative; width: 500px; height: 500px;\" ></ div > < script > // Build an ad-hoc MVS view const builder = molstar . PluginExtensions . mvs . MVSData . createBuilder (); const structure = builder . download ({ url : 'https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif' }) . parse ({ format : 'bcif' }) . modelStructure ({}); structure . component ({ selector : 'polymer' }) . representation ({ type : 'cartoon' }) . color ({ color : 'green' }); structure . component ({ selector : 'ligand' }) . label ({ text : 'Retinoic acid' }) . focus ({}) . representation ({ type : 'ball_and_stick' }) . color ({ color : '#cc3399' }); const mvsData = builder . getState (); // Initialize viewer and load MVSJ molstar . Viewer . create ( 'viewer3' , { layoutIsExpanded : false , layoutShowControls : false }) . then ( viewer => molstar . PluginExtensions . mvs . loadMVS ( viewer . plugin , mvsData , { sourceUrl : undefined , sanityChecks : true , replaceExisting : false })); </ script > </ body > </ html > Result: // Build an ad-hoc MVS view const builder = molstar.PluginExtensions.mvs.MVSData.createBuilder(); const structure = builder .download({ url: 'https://www.ebi.ac.uk/pdbe/entry-files/1cbs.bcif' }) .parse({ format: 'bcif' }) .modelStructure({}); structure .component({ selector: 'polymer' }) .representation({ type: 'cartoon' }) .color({ color: 'green' }); structure .component({ selector: 'ligand' }) .label({ text: 'Retinoic acid' }) .focus({}) .representation({ type: 'ball_and_stick' }) .color({ color: '#cc3399' }); const mvsData = builder.getState(); // Initialize viewer and load MVSJ molstar.Viewer .create('viewer3', { layoutIsExpanded: false, layoutShowControls: false }) .then(viewer => molstar.PluginExtensions.mvs.loadMVS(viewer.plugin, mvsData, { sourceUrl: undefined, sanityChecks: true, replaceExisting: false }));","title":"Construct MVS view on frontend and pass to the viewer"},{"location":"mvs-molstar-extension/load-extensions/","text":"Mol* MVS Extension: Custom Load Extensions Mol* MolViewSpec extension provides functionality for customizing the state loading. is_hidden Custom State Example Example State The following state assigns is_hidden custom state to the representation: builder = create_builder () ( builder . download ( url = \"https://files.wwpdb.org/download/1cbs.cif\" ) . parse ( format = \"mmcif\" ) . model_structure () . component () . representation ( custom = { \"is_hidden\" : True }) . color ( color = \"blue\" ) ) The Extension Based on the is_hidden property, the extension will update the state of the corresponding Mol* node when loading the state to make the representation hidden: import { MolstarLoadingExtension } from 'molstar/lib/extensions/mvs/load' ; export const IsHiddenCustomStateExtension : MolstarLoadingExtension < {} > = { id : 'is-hidden-custom-state' , description : 'Allow updating initial visibility of nodes' , createExtensionContext : () => ({}), action : ( updateTarget , node ) => { if ( ! node . custom || ! node . custom ? . is_hidden ) return ; updateTarget . update . to ( updateTarget . selector ). updateState ({ isHidden : true }); }, }; Using the Extension To load the state with the custom extension, use: await loadMVS ( this . plugin , data , { replaceExisting : false , extensions : [ IsHiddenCustomStateExtension ] }); See Mol* MVS Extension for more information how to use the loadMVS function.","title":"Custom Load Extensions"},{"location":"mvs-molstar-extension/load-extensions/#mol-mvs-extension-custom-load-extensions","text":"Mol* MolViewSpec extension provides functionality for customizing the state loading.","title":"Mol* MVS Extension: Custom Load Extensions"},{"location":"mvs-molstar-extension/load-extensions/#is_hidden-custom-state-example","text":"","title":"is_hidden Custom State Example"},{"location":"mvs-molstar-extension/load-extensions/#example-state","text":"The following state assigns is_hidden custom state to the representation: builder = create_builder () ( builder . download ( url = \"https://files.wwpdb.org/download/1cbs.cif\" ) . parse ( format = \"mmcif\" ) . model_structure () . component () . representation ( custom = { \"is_hidden\" : True }) . color ( color = \"blue\" ) )","title":"Example State"},{"location":"mvs-molstar-extension/load-extensions/#the-extension","text":"Based on the is_hidden property, the extension will update the state of the corresponding Mol* node when loading the state to make the representation hidden: import { MolstarLoadingExtension } from 'molstar/lib/extensions/mvs/load' ; export const IsHiddenCustomStateExtension : MolstarLoadingExtension < {} > = { id : 'is-hidden-custom-state' , description : 'Allow updating initial visibility of nodes' , createExtensionContext : () => ({}), action : ( updateTarget , node ) => { if ( ! node . custom || ! node . custom ? . is_hidden ) return ; updateTarget . update . to ( updateTarget . selector ). updateState ({ isHidden : true }); }, };","title":"The Extension"},{"location":"mvs-molstar-extension/load-extensions/#using-the-extension","text":"To load the state with the custom extension, use: await loadMVS ( this . plugin , data , { replaceExisting : false , extensions : [ IsHiddenCustomStateExtension ] }); See Mol* MVS Extension for more information how to use the loadMVS function.","title":"Using the Extension"}]}